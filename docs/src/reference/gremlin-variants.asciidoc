////
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
////
[[gremlin-variants]]
Gremlin Variants
================

image::gremlin-house-of-mirrors.png[width=1024]

Gremlin is a graph traversal language that makes use of two fundamental programming constructs:
link:https://en.wikipedia.org/wiki/Function_composition[function composition] and
link:https://en.wikipedia.org/wiki/Nested_function[function nesting]. Given this generality, it is possible to embed
Gremlin in any modern programming language.

IMPORTANT: Gremlin-Java is the canonical representation of Gremlin and any (proper) Gremlin language variant will emulate its
structure as best as possible given the constructs of the host language. A strong correspondence between variants ensures
that the general Gremlin reference documentation is applicable to all variants and that users moving between development
languages can easily adopt the Gremlin language variant for that language.

image::gremlin-variant-architecture.png[width=650,float=left]

NOTE: The information herein describes how to use the Gremlin language variants distributed
with Apache TinkerPop. For information on how to build a Gremlin language variant,
please review the link:http://tinkerpop.apache.org/docs/current/tutorials/gremlin-language-variants/[Gremlin Language Variants]
tutorial.

[[gremlin-python]]
Gremlin-Python
--------------

image:gremlin-python-drawing.png[width=130,float=right] Apache TinkerPop's Gremlin-Python implements Gremlin within
the link:https://www.python.org/[Python] language and can be used on any Python virtual machine including the popular
link:https://en.wikipedia.org/wiki/CPython[CPython] machine. Python's syntax has the same constructs as Java including
"dot notation" for function chaining (`a.b.c`), round bracket function arguments (`a(b,c)`), and support for global
namespaces (`a(b())` vs `a(__.b())`). As such, anyone familiar with Gremlin-Java will immediately be able to work
with Gremlin-Python. Moreover, there are a few added constructs to Gremlin-Python that make traversals a bit more succinct.

CAUTION: Python has `as`, `in`, `and`, `or`, `is`, `not`, `from`, and `global` as reserved words. Gremlin-Python simply
prefixes `_` in front of these terms for their use with graph traversal. For instance: `g.V()._as('a')._in()._as('b').select('a','b')`.

To install Gremlin-Python, simply use Python's link:https://en.wikipedia.org/wiki/Pip_(package_manager)[pip] package manager.

[source,bash]
pip install gremlin_python

There are three primary classes distributed with Gremlin-Python: `GraphTraversalSource`, `GraphTraversal`, and `__`.

[source,python]
from gremlin_python import statics
from gremlin_python.structure.remote_graph import RemoteGraph
from gremlin_python.process.graph_traversal import GraphTraversalSource
from gremlin_python.process.graph_traversal import GraphTraversal
from gremlin_python.process.graph_traversal import __
from gremlin_python.driver.websocket_remote_connection import WebSocketRemoteConnection

These classes mirror `GraphTraversalSource`, `GraphTraversal`, and `__`, respectively in Gremlin-Java. The `GraphTraversalSource`
requires a driver in order to communicate with <<gremlin-server,GremlinServer>> (or any <<connecting-via-remotegraph,`RemoteConnection`>>-enabled server).
The `gremlin_rest_driver` is provided with Apache TinkerPop and it serves as a simple (though verbose) driver that sends traversals to GremlinServer
via HTTP POST (using link:http://docs.python-requests.org/[requests]) and in return, is provided <<graphson-reader-writer,GraphSON>>-encoded results.
`WebSocketRemoteConnection` extends the abstract class `RemoteConnection` in `gremlin_python.driver`.

IMPORTANT: For developers wishing to provide another *driver implementation*, be sure to extend `RemoteConnection` in
`gremlin_python.driver` so it can then be used by Gremlin-Python's `GraphTraversal`.

When GremlinServer is running, Gremlin-Python can communicate with GremlinServer. The `conf/gremlin-server-rest.modern.yaml`
configuration is used to expose GremlinServer's REST interface.

[source,bash]
----
$ bin/gremlin-server.sh conf/gremlin-server-rest-modern.yaml
[INFO] GremlinServer -
       \,,,/
       (o o)
---oOOo-(3)-oOOo---

[INFO] GremlinServer - Configuring Gremlin Server from conf/gremlin-server-rest-modern.yaml
[INFO] GraphManager - Graph [graph] was successfully configured via [conf/tinkergraph-empty.properties].
[INFO] ScriptEngines - Loaded gremlin-groovy ScriptEngine
[INFO] GremlinExecutor - Initialized gremlin-groovy ScriptEngine with scripts/generate-modern.groovy
[INFO] ServerGremlinExecutor - A GraphTraversalSource is now bound to [g] with graphtraversalsource[tinkergraph[vertices:0 edges:0], standard]
[INFO] AbstractChannelizer - Configured application/json with org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerV1d0
[INFO] GremlinServer$1 - Channel started at port 8182.
----

Within the CPython console, it is possible to evaluate the following.

[source,python]
graph = RemoteGraph(WebSocketsRemoteConnection('ws://localhost:8182','g'))
g = graph.traversal()

When the traversal above is submitted to the `RemoteConnection`, it's `Bytecode` is sent in order to construct the equivalent traversal
in GremlinServer (thus, remotely). The bytecode is analyzed to determine which language the bytecode should be translated to.
If the traversal does not have lambdas, it will typically use Gremlin-Java. If it has lambdas written in Groovy,
it will use Gremlin-Groovy (e.g. `GremlinGroovyScriptEngine`). Likewise, if it has lambdas represented in Python, it will use
Gremlin-Python (e.g. `GremlinJythonScriptEngine`).

Gremlin-Python Sugar
~~~~~~~~~~~~~~~~~~~~

Python supports meta-programming and operator overloading. There are three uses of these techniques in Gremlin-Python that
makes traversals a bit more concise.

[gremlin-python,modern]
----
g.V().both()[1:3].toList()
g.V().both()[1].toList()
g.V().both().name.toList()
----

Static Enums and Methods
~~~~~~~~~~~~~~~~~~~~~~~~

Gremlin has various tokens (e.g. `T`, `P`, `Order`, `Operator`, etc.) that are represented in Gremlin-Python as Python `Enums`.

[source,python]
from gremlin_python.process.traversal import T
from gremlin_python.process.traversal import Order
from gremlin_python.process.traversal import Cardinality
from gremlin_python.process.traversal import Column
from gremlin_python.process.traversal import Direction
from gremlin_python.process.traversal import Operator
from gremlin_python.process.traversal import P
from gremlin_python.process.traversal import Pop
from gremlin_python.process.traversal import Scope
from gremlin_python.process.traversal import Barrier

These can be used analogously to how they are used in Gremlin-Java.

[gremlin-python,modern]
----
g.V().hasLabel('person').has('age',P.gt(30)).order().by('age',Order.decr).toList()
----

Moreover, by importing the `statics` of Gremlin-Python, the class prefixes can be removed.

[source,python]
statics.load_statics(globals())

With statics loaded its possible to represent the above traversal as below.

[gremlin-python,modern]
----
g.V().hasLabel('person').has('age',gt(30)).order().by('age',decr).toList()
----

Finally, statics includes all the `__`-methods and thus, anonymous traversals like `__.out()` can be expressed as below.
That is, without the `__.`-prefix.

[gremlin-python,modern]
----
g.V().repeat(out()).times(2).name.fold().toList()
----

RemoteConnection Bindings
~~~~~~~~~~~~~~~~~~~~~~~~~

When a traversal bytecode is sent over a `RemoteConnection` (e.g. GremlinServer), it will be translated, compiled, and executed accordingly.
If the same traversal is sent again, translation and compilation can be skipped as the previously compiled version is typically cached.
Many traversals are unique up to some parameterization. For instance, `g.V(1).out('created').name` is considered different
from `g.V(4).out('created').name'` as they are different scripts. However, `g.V(x).out('created').name` with bindings of `{x : 1}` and
`{x : 4}` are the same. If a traversal is going to be executed repeatedly, but with different parameters, then bindings should be used.
In Gremlin-Python, bindings are 2-tuples and used as follows.

[gremlin-python,modern]
----
g.V(('id',1)).out('created').name.toList()
g.V(('id',4)).out('created').name.toList()
----

The Lambda Solution
~~~~~~~~~~~~~~~~~~~

Supporting link:https://en.wikipedia.org/wiki/Anonymous_function[anonymous functions] across languages is extremely difficult.
As a simple solution, it is up to the Gremlin variant to decide lambdas (in any language) should be expressed and ultimately
encoded in the standard `Bytecode` format. In Gremlin-Python, a link:https://docs.python.org/2/reference/expressions.html#lambda[Python lambda]
should be a zero-arg callable that returns a string representation of a lambda. The default lambda language is `gremlin-jython`
and can be changed via `statics.default_lambda_language.` When the lambda is represented in `Bytecode` its language is encoded
such that the remote connection host can infer which translator to use. A zero-arg lambda yields a string representation of a lambda in Gremlin-Jython.
For example, `g.V().out().map(lambda: "lambda x: x.get().value('name').length()").sum().toList()`.

[gremlin-python,modern]
----
g.V().out().map(lambda: ("it.get().value('name').length()", "gremlin-groovy")).sum().toList()
statics.default_lambda_language = 'gremlin-groovy'
g.V().out().map(lambda: "it.get().value('name').length()").sum().toList()
----

1. A zero-arg lambda yields 2-tuple where the second element is the lambda language.
2. The default lambda language can be statically changed.
3. A zero-arg lambda yields a string representation of a closure in Gremlin-Groovy.

