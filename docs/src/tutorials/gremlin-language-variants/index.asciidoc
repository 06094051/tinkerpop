////
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
////

image::apache-tinkerpop-logo.png[width=500]

Gremlin Language Variants
-------------------------

Gremlin is an embeddable query language able to represent itself within the constructs of existing programming languages.
Any programming language that supports function composition (e.g. fluent chaining) and function nesting (e.g. call stacks)
can support Gremlin. With Gremlin, the distinction between a programming language and a query language is not be as
strongly divided as they have historically been. For instance, with Gremlin-Java, the developer is able to have their
application code and their graph database queries at the same level of abstraction. A simple example is presented below
where the `MyApplication` Java class contains both application-level and database-level code all within the constructs
of Java.

[source,java]
----
public class MyApplication {

  public static void run(final String[] args) {
    // assumes args[0] is a configuration file location
    Graph graph = GraphFactory.open(args[0]);
    GraphTraversalSource g = graph.traversal();

    // assumes that args[1] is a vertex id
    double averageRating =
      g.V(args[1]).out("created").inE("rated").
        values("stars").mean().next();

    String personName = g.V(args[1]).values("name").next();

    System.out.println("Average rating of " + personName + " projects is: " + averageRating);
  }

}
----

In query languages like link:https://en.wikipedia.org/wiki/SQL[SQL], the user must construct a string representation of
their query and submit it to the database for evaluation. The same example above is presented below in Java using SQL and the
link:https://en.wikipedia.org/wiki/Java_Database_Connectivity[JDBC] interface.

[source,java]
----
public class MyApplication {

  public static void run(final String[] args) {
    // assumes args[0] is a URI to the database
    Connection connection = DriverManager.getConnection(args[0])
    Statement statement = connection.createStatement();

    // assumes that args[1] is a vertex id
    ResultSet result = statement.executeQuery(
      "SELECT p.name as NAME, AVG(c.stars) as AVERAGE FROM PERSONS p" +
        "INNER JOIN CREATED c ON c.person = p.id " +
        "WHERE p.id = '" + args[1] + "'");

    result.next();
    double averageRating = result.getDouble("AVERAGE");
    String personName = result.getString("NAME");

    System.out.println("Average rating of " + personName + " projects is: " + averageRating);
  }

}
----

The purpose of this tutorial is to explain how to develop a Gremlin language variant. That is, for those developers that
are interested in supporting Gremlin in their native language and there currently does not exist a (good) Gremlin variant for
their language, can develop one for both their language community and the Apache TinkerPop community to use. For this
tutorial, Python will be used and three different design models are presented. Any variant will use one of the models
below.

1. <<using-jython-and-the-jvm,**Using Jython and the JVM**>>: This is perhaps the easiest way to produce a Gremlin
language variant. With link:https://www.jcp.org/en/jsr/detail?id=223[JSR-223], any language compiler written for the JVM
can directly access the JVM and any of its libraries (including Gremlin).

2. <<using-python-and-jni,**Using Python and JNI**>>: This is similar to the first model save that a non-JVM Python version is used.
However, the JVM is interacted with using link:https://en.wikipedia.org/wiki/Java_Native_Interface[JNI] to construct a Gremlin traversal
for execution on the JVM, but whose result set is converted to Python for the native language developer.

3. <<using-python-and-gremlin-server,**Using Python and GremlinServer**>>: This model requires that there exist a Python
class that mimics Gremlin-Java's `GraphTraversal` API. With each method calls of this Python class, a `ScriptEngine`
string is constructed (e.g. Gremlin-Groovy). Ultimately, that constructed traversal (represented behind the
scenes as a string) is submitted to a Gremlin-Server compliant graph system for evaluation.

IMPORTANT: Gremlin-Java is considered the idiomatic, standard implementation of Gremlin. Any Gremlin language variant,
regardless of the implementation model chosen, **must**, within the constraints of the host language, be in 1-to-1
correspondence with Gremlin-Java.

Language Drivers vs. Language Variants
--------------------------------------

Language Drivers
~~~~~~~~~~~~~~~~

A language driver is a software library that is able to communicate with a TinkerPop `Graph` whether directly via the JVM
or indirectly via link:http://tinkerpop.apache.org/docs/x.y.z/reference/#gremlin-server[Gremlin Server]. By in large, if a
language driver is being developed, it is being developed to interact with GremlinServer or a
link:http://tinkerpop.apache.org/docs/x.y.z/reference/#connecting-via-remotegraph[RemoteConnection].
Language drivers ensure that `Traversals` are submitted to a TinkerPop-enabled graph system and the results are translated
back into the host language's type system. For instance, resultant doubles are coerced to floats in Python.

This tutorial is not about language drivers, but about language variants. Moreover, community libraries should make this
distinction clear and should not develop libraries that serve both roles. Language drivers will be useful to a collection
of language variants -- including `GraphTraversal`-variants but also other DSL-variants (e.g. `SocialTraversal`).

IMPORTANT: `GraphTraversal` is a particular Gremlin domain-specific language (link:https://en.wikipedia.org/wiki/Domain-specific_language[DSL]),
albeit the most popular and foundational DSL. If another DSL is created, then the same techniques discussed in this tutorial
for `GraphTraversal` apply to `XXXTraversal`.

Language Variants
~~~~~~~~~~~~~~~~~

A language variant is a software library that allows a developer to write a Gremlin traversal within their native
programming language. The language variant is responsible for creating a `Traversal` instance that will ultimately be
evaluated by a TinkerPop-enabled graph system. The `Traversal` instance is either created directly on the JVM or as a String
representation for ultimate generation by a `ScriptEngine` (typically, via GremlinServer).

Every language variant, regardless of the implementation details, will have to account for the four core concepts below:

1. `Graph` (**data**): The source of the graph data to be traversers and which enables the creation of a `GraphTraversalSource` via `graph.traversal()`.

2. `GraphTraversalSource` (**compiler**): This is the typical `g` reference. It maintains the `withXXX()`-strategy
methods as well as the "traversal spawn"-methods such as `V()`, `E()`, `addV()`, etc. A traversal source is responsible
for specifying how the ultimate traversal will be compiled by way of its registered `TraversalStrategies`.

3. `GraphTraversal` (**function composition**): The primary traversal class that maintains every traversal step such as `out()`, `groupCount()`,
`match()`, etc. This fluent interface support method chaining and thus, a linear "left-to-right" representation of a traversal.

4. `__` (**function nesting**) : The anonymous traversal class that is used for nested traversals. An example includes `repeat(__.out())`.
This static interface enables the "up-and-down" representation of a traversal.

Both `GraphTraversal` and `__` define the structure of the Gremlin language. Gremlin is a _two-dimensional language_ supporting
linear, nested step sequences. Historically, many Gremlin language variants have failed to make the distinctions above clear
and in doing so, either complicate their implementations or yield variants that are not in 1-to-1 correspondence with Gremlin-Java.

IMPORTANT: The term "Gremlin-Java" denotes the language that is defined by `GraphTraversalSource`, `GraphTraversal`,
and `__`. These three classes exist in `org.apache.tinkerpop.gremlin.process.traversal.dsl.graph` and form the definitive
representation of the Gremlin traversal language.

[[using-jython-and-the-jvm]]
Using Jython and the JVM
------------------------

link:http://www.jython.org/[Jython] is a link:https://www.jcp.org/en/jsr/detail?id=223[JSR-223] implementation that allows
for the evaluation of Python on the link:https://en.wikipedia.org/wiki/Java_virtual_machine[Java virtual machine].
In other words, Jython's virtual machine is not the standard link:https://wiki.python.org/moin/CPython[CPython] reference implementation
distributed with most operating systems, but instead the JVM. The benefit of Jython is that Python code and classes can interact
with the Java API and any Java packages on the `CLASSPATH`. This makes any JSR-224 Gremlin language variant "implementation" trivial.

[source,python]
----
>>> import sys
# this list is longer, including all jars in lib/, not just Apache TinkerPop jars
>>> sys.path.append("/usr/local/apache-gremlin-console-x.y.z-standalone/lib/gremlin-console-x.y.z.jar")
>>> sys.path.append("/usr/local/apache-gremlin-console-x.y.z-standalone/lib/gremlin-core-x.y.z.jar")
>>> sys.path.append("/usr/local/apache-gremlin-console-x.y.z-standalone/lib/gremlin-driver-x.y.z.jar")
>>> sys.path.append("/usr/local/apache-gremlin-console-x.y.z-standalone/lib/gremlin-shaded-x.y.z.jar")
>>> sys.path.append("/usr/local/apache-gremlin-console-x.y.z-standalone/ext/tinkergraph-gremlin/lib/tinkergraph-gremlin-x.y.z.jar")
# import Java classes
>>> from org.apache.tinkerpop.gremlin.tinkergraph.structure import TinkerFactory
>>> from org.apache.tinkerpop.gremlin.process.traversal.dsl.graph import __
>>> from org.apache.tinkerpop.gremlin.process.traversal import *
>>> from org.apache.tinkerpop.gremlin.structure import *
# create a the toy "modern" graph for the example and spawn a GraphTraversalSource
>>> graph = TinkerFactory.createModern()
>>> g = graph.traversal()
# The Jython shell does not automatically iterate Iterators like the Gremlin Console
>>> g.V().hasLabel("person").out("knows").out("created")
[GraphStep(vertex,[]), HasStep([~label.eq(person)]), VertexStep(OUT,[knows],vertex), VertexStep(OUT,[created],vertex)]
# toList() will do the iteration and return the results as a list
>>> g.V().hasLabel("person").out("knows").out("created").toList()
[v[5], v[3]]
>>> g.V().repeat(__.out()).times(2).values("name").toList()
[ripple, lop]
# results can be interacted with using Python
>>> g.V().repeat(__.out()).times(2).values("name").toList()[0]
u'ripple'
>>> g.V().repeat(__.out()).times(2).values("name").toList()[0][0:3].upper()
u'RIP'
>>>
----

Most every JSR-223 `ScriptEngine` language will allow the developer to immediately interact with `GraphTraversal`.
The benefit of this model is that nearly every major programming language has a respective `ScriptEngine`:
link:https://en.wikipedia.org/wiki/Nashorn_(JavaScript_engine)[JavaScript], link:http://groovy-lang.org/[Groovy],
link:http://www.scala-lang.org/[Scala], Lisp (link:https://clojure.org/[Clojure]), link:http://jruby.org/[Ruby], etc. A
list of implementations is provided link:https://en.wikipedia.org/wiki/List_of_JVM_languages[here].

Traversal Wrappers
~~~~~~~~~~~~~~~~~~

While it is possible to simply interact with Java classes in a `ScriptEngine` implementation, such Gremlin language variants
will not leverage the unique features of the host language. It is for this reason that link:https://github.com/mpollmeier/gremlin-scala[Gremlin-Scala]
was developed. Scala provides many syntax niceties not available in Java. To leverage these niceties, Gremlin-Scala "wraps"
`GraphTraversal` in order to provide Scala-idiomatic extensions. Another example is Apache TinkerPop's
Gremlin-Groovy which does the same via the link:http://tinkerpop.apache.org/docs/x.y.z/reference/#sugar-plugin[Sugar plugin],
but uses link:http://groovy-lang.org/metaprogramming.html[meta-programming] instead of object wrapping.

The Python (via Jython) classes below wrap `GraphTraversalSource` and `GraphTraversal`. In doing so, they add methods
that apply Python-specific constructs to Gremlin. In particular, `__getitem__` and `__getattr__` "magic methods" are leveraged.
It is important to note that the classes below are **not complete** and only provide enough functionality to demonstrate this
sub-sections tutorial material.

[source,python]
----
# GraphTraversalSource (incomplete)
class JythonGraphTraversalSource(object):
  def __init__(self, traversalSource):
    self.traversalSource = traversalSource
  def V(self,*args):
    return JythonGraphTraversal(self.traversalSource.V(*args))
  def __repr__(self):
    return self.traversalSource.toString()

# GraphTraversal (incomplete)
class JythonGraphTraversal(object):
  def __init__(self, traversal):
    self.traversal = traversal
  def V(self,*args):
    self.traversal = self.traversal.V(args)
    return self
  def values(self, *propertyKeys):
    self.traversal = self.traversal.values(propertyKeys)
    return self
  def toList(self):
    return self.traversal.toList()
  def __repr__(self):
    return self.traversal.toString()
  def __getitem__(self,index):
    if type(index) is int:
      self.traversal = self.traversal.range(indices,indices+1)
    elif type(index) is slice:
        self.traversal = self.traversal.range(index.start,index.stop)
    else:
        raise TypeError("index must be int or slice")
    return self
  def __getattr__(self,key):
    return self.values(key)
----

The two methods `__getitem__` and `__getattr__` support Python _slicing_ and _object attribute interception_, respectively.
In this way, the host language is able to use its native constructs with Gremlin.

[source,python]
----
>>> graph
tinkergraph[vertices:6 edges:6]
>>> g = JythonGraphTraversalSource(graph.traversal())
>>> g
graphtraversalsource[tinkergraph[vertices:6 edges:6], standard]
# Python slices are converted into range()-steps
>>> g.V()[1:4]
[GraphStep(vertex,[]), RangeGlobalStep(1,4)]
# Python attribute selections are converted into values()-steps
>>> g.V()[1:4].name
[GraphStep(vertex,[]), RangeGlobalStep(1,4), PropertiesStep([name],value)]
>>> g.V()[1:4].name.toList()
[vadas, lop, josh]
----

IMPORTANT: Gremlin-Java serves as the standard/default representation of the Gremlin traversal language. Any Gremlin
language variant **must** provide all the same functionality (methods) as `GraphTraversal`, but **can** extend it
with host language specific constructs. This means that the extensions **must** compile to `GraphTraversal`-specific
steps. A Gremlin language variant **should not** add steps/methods that do not exist in `GraphTraversal`. If such an extension
is desired, the language variant designer should submit a proposal to link:http://tinkerpop.apache.org[Apache TinkerPop]
to have the extension added to a future release of Gremlin.

Auto-Generated Traversal Wrappers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the previous example, only a subset of the `GraphTraversalSource` and `GraphTraversal` methods were implemented in the
corresponding Jython-based Python classes. Unfortunately, adding the near 200 `GraphTraversal` methods to a wrapper is
both tedious and error-prone. To alleviate this pain, Python classes can be dynamically created using Groovy and
link:https://en.wikipedia.org/wiki/Reflection_(computer_programming)#Java[Java reflection].
The Groovy code for constructing the `JythonGraphTraversal` class source is reviewed below. By simply executing this code
in the link:http://tinkerpop.apache.org/docs/x.y.z/reference/#gremlin-console[Gremlin Console], the `gremlin-jython.py` file
is generated and can be used by Jython.

[source,groovy]
----
pythonClass = new StringBuilder();
pythonClass.append("from org.apache.tinkerpop.gremlin.process.traversal import *\n")
pythonClass.append("from org.apache.tinkerpop.gremlin.structure import *\n")
pythonClass.append("from org.apache.tinkerpop.gremlin.process.traversal.dsl.graph import __ as anon\n\n")
//////////////////////////
// GraphTraversalSource //
//////////////////////////
methods = GraphTraversalSource.getMethods().collect{methodMap[it.name]} as Set; []
pythonClass.append(
"""class JythonGraphTraversalSource(object):
  def __init__(self, traversalSource):
    self.traversalSource = traversalSource
  def __repr__(self):
    return self.traversalSource.toString()
""")
methods.each{ method ->
  returnType = (GraphTraversalSource.getMethods() as Set).findAll{it.name.equals(method)}.collect{it.returnType}[0]
  if(null != returnType && TraversalSource.isAssignableFrom(returnType)) {
  pythonClass.append(
"""  def ${method}(self, *args):
    self.traversalSource = self.traversalSource.${method}(*args)
    return self
""")
  } else if(null != returnType && Traversal.isAssignableFrom(returnType)) {
  pythonClass.append(
"""  def ${method}(self, *args):
    return JythonGraphTraversal(self.traversalSource.${method}(*args))
""")
  } else {
  pythonClass.append(
"""  def ${method}(self, *args):
    return self.traversalSource.${method}(*args)
""")
  }
}; []
pythonClass.append("\n\n")

////////////////////
// GraphTraversal //
////////////////////
methodMap = [as:"_as",in:"_in",and:"_and",or:"_or",is:"_is",not:"_not",from:"_from"].withDefault{ it }  //// <1>
invertedMethodMap = [_as:"as",_in:"in",_and:"and",_or:"or",_is:"is",_not:"not",_from:"from"].withDefault{ it }
pythonClass.append(                                                           //// <2>
"""class JythonGraphTraversal(object):
  def __init__(self, traversal):
    self.traversal = traversal
  def __repr__(self):
    return self.traversal.toString()
  def __getitem__(self,index):
    if type(index) is int:
      self.traversal = self.traversal.range(indices,indices+1)
    elif type(index) is slice:
        self.traversal = self.traversal.range(index.start,index.stop)
    else:
        raise TypeError("index must be int or slice")
    return self
  def __getattr__(self,key):
    return self.values(key)
""")
methods = GraphTraversal.getMethods().collect{methodMap[it.name]} as Set; []  //// <3>
methods.each{ method ->
  returnType = (GraphTraversal.getMethods() as Set).findAll{it.name.equals(method)}.collect{it.returnType}[0]
  if(null != returnType && Traversal.isAssignableFrom(returnType)) {          //// <4>
  pythonClass.append(
"""  def ${method}(self, *args):
    self.traversal = self.traversal.${invertedMethodMap[method]}(*args)
    return self
""")
  } else {
  pythonClass.append(                                                         //// <5>
"""  def ${method}(self, *args):
    return self.traversal.${invertedMethodMap[method]}(*args)
""")
  }
}; []
pythonClass.append("\n\n")

////////////////////////
// AnonymousTraversal //
////////////////////////
methods = __.getMethods().collect{methodMap[it.name]} as Set; []
pythonClass.append("class __(object):\n");
methods.each{ method ->
  pythonClass.append(
"""  @staticmethod
  def ${method}(*args):
    return anon.${invertedMethodMap[method]}(*args)
""")
}; []
pythonClass.append("\n\n")

// save to a python file
file = new File("/usr/local/apache-gremlin-console-x.y.z-standalone/lib/gremlin-jython.py")
file.delete()
pythonClass.eachLine{ file.append(it + "\n") }
----

<1> There are numerous `GraphTraversal` step names that are reserved words in Python. Prefixing these steps with `_` is the chosen workaround.
<2> Add Gremlin-Jython specific methods to `JythonGraphTraversal`. These methods are idiomatic Python extensions, not step additions.
<3> Use Java reflection to get all the methods of `GraphTraversal`.
<4> If the method is a fluent traversal-method, then mutate the underlying/wrapped `GraphTraversal` instance accordingly.
<5> If the method is not a fluent traversal-method, return the result of applying the method.

From the Jython console, `gremlin-jython.py` is loaded and a complete Gremlin language variant is born: **Gremlin-Jython**.
The generated file is available at link:../../resources/gremlin-jython.py[gremlin-jython.py].

[source,python]
----
>>> execfile("/usr/local/apache-gremlin-console-x.y.z-standalone/lib/gremlin-jython.py")
>>> graph = TinkerFactory.createModern()
>>> g = JythonGraphTraversalSource(graph.traversal())
# using the Gremlin-Jython __getattr__ and __getitem__ extensions and anonymous traversals
>>> g.V().repeat(__.both("created")).times(2).name[1:3].path().toList()
[[v[1], v[3], v[4], josh], [v[1], v[3], v[6], peter]]
# JythonGraphTraversalSource works as expected -- an example using Gremlin-Jython w/ OLAP
>>> g = g.withComputer()
>>> g
graphtraversalsource[tinkergraph[vertices:6 edges:6], graphcomputer]
>>> g.V().repeat(__.both("created")).times(2).name[1:3].path().toList()
[[v[3], v[4], v[5], ripple], [v[1], v[4], v[5], ripple]]
>>>
----

Gremlin-Jython was simple to create. Unfortunately, this simplicity is not without its problems. These problems are itemized below.
The interested reader can solve the aforementioned problems as a training exercise.

* The Gremlin-Jython API is non-informative as all methods take a tuple reference (`*args`).
** The Gremlin-Java link:http://tinkerpop.apache.org/javadocs/x.y.z/full/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html[JavaDoc] would be a sufficient guide to Gremlin-Jython (minus the extensions).
* Lambdas are not supported with, for example, `map(lambda x: x.get())` throwing an exception.
** Python type inspection with a typecast to a `java.util.function.Function` lambda wrapper would solve this problem.
* `__` is always required for anonymous traversals.
** By placing the `@staticmethods` outside of the `__` Jython class, the methods would be globally scoped (analogous to `import static` in Java).


[[using-python-and-jni]]
Using Python and JNI
--------------------

[[using-python-and-gremlin-server]]
Using Python and GremlinServer
------------------------------

The last model does not leverage the JVM directly. Instead, it constructs a `String` representation of a `Traversal`
that will ultimately be evaluated by a registered `ScriptEngine` at a GremlinServer or `RemoteConnection`. It is up to the
language variant designer to choose a _language driver_ to use for submitting the generated String and processing its
returned results. For this example, the link:https://github.com/davebshow/gremlinclient[gremlinclient] Python language
driver is used and its installation via link:https://en.wikipedia.org/wiki/Pip_(package_manager)[pip] is provided below.

[source,bash]
----
$ # sudo easy_install pip
$ sudo pip install gremlinclient
----

IMPORTANT: When language drivers are seperated from language variants, language variants can more easily choose a language
driver to use. In fact, it is possible for multiple language drivers to be supported by a language variant as GremlinServer,
for example, supports WebSockets, REST, etc.

[source,groovy]
----
pythonClass = new StringBuilder()
pythonClass.append("from tornado import gen\n")
pythonClass.append("from tornado.ioloop import IOLoop\n")
pythonClass.append("from gremlinclient.tornado_client import submit\n")
pythonClass.append("""
class Helper(object):
  @staticmethod
  def stringOrObject(arg):
    if (type(arg) is str and
       not(arg.startswith("P.")) and
       not(arg.startswith("Order.")) and
       not(arg.startswith("T.")) and
       not(arg.startswith("Pop.")) and
       not(arg.startswith("Column."))):
      return "\\"" + arg + "\\""
    elif type(arg) is bool:
      return str(arg).lower()
    else:
      return str(arg)
  @staticmethod
  def stringify(*args):
    if len(args) == 0:
      return ""
    elif len(args) == 1:
      return Helper.stringOrObject(args[0])
    else:
      return ", ".join(Helper.stringOrObject(i) for i in args)
  @staticmethod
  @gen.coroutine
  def submit(traversalString):
    response = yield submit("ws://localhost:8182/", traversalString)
    while True:
      result = yield response.read()
      if result is None:
        break
      raise gen.Return(result.data)\n

""");

//////////////////////////
// GraphTraversalSource //
//////////////////////////
methods = GraphTraversalSource.getMethods().collect{methodMap[it.name]} as Set; []
pythonClass.append(
"""class PythonGraphTraversalSource(object):
  def __init__(self, traversalSourceString):
    self.traversalSourceString = traversalSourceString
  def __repr__(self):
    return self.traversalSourceString
""")
methods.each{ method ->
  returnType = (GraphTraversalSource.getMethods() as Set).findAll{it.name.equals(method)}.collect{it.returnType}[0]
  if(null != returnType && Traversal.isAssignableFrom(returnType)) {
  pythonClass.append(
"""  def ${method}(self, *args):
    return PythonGraphTraversal(self.traversalSourceString + ".${method}(" + Helper.stringify(*args) + ")")
""")
  } else {
  pythonClass.append(
"""  def ${method}(self, *args):
    self.traversalSourceString = self.traversalSourceString + ".${method}(" + Helper.stringify(*args) + ")"
    return self
""")
  }
}; []
pythonClass.append("\n\n")

////////////////////
// GraphTraversal //
////////////////////
methodMap = [as:"_as",in:"_in",and:"_and",or:"_or",is:"_is",not:"_not",from:"_from"].withDefault{ it }
invertedMethodMap = [_as:"as",_in:"in",_and:"and",_or:"or",_is:"is",_not:"not",_from:"from"].withDefault{ it }
methods = GraphTraversal.getMethods().collect{methodMap[it.name]} as Set; []
methods.remove("toList")
pythonClass.append(
"""class PythonGraphTraversal(object):
  def __init__(self, traversalString):
    self.traversalString = traversalString
    self.result = None
  def __repr__(self):
    return self.traversalString
  def __getitem__(self,index):
    if type(index) is int:
      return self.range(indices,indices+1)
    elif type(index) is slice:
      return self.range(index.start,index.stop)
    else:
      raise TypeError("index must be int or slice")
  def __getattr__(self,key):
    return self.values(key)
  def toList(self):
    return IOLoop.current().run_sync(lambda: Helper.submit(self.traversalString))
""")
methods.each{ method ->
  pythonClass.append(
"""  def ${method}(self, *args):
    self.traversalString = self.traversalString + ".${invertedMethodMap[method]}(" + Helper.stringify(*args) + ")"
    return self
""")
}; []
pythonClass.append("\n\n")

////////////////////////
// AnonymousTraversal //
////////////////////////
methods = __.getMethods().collect{methodMap[it.name]} as Set; []
pythonClass.append("class __(object):\n");
methods.each{ method ->
  pythonClass.append(
"""  @staticmethod
  def ${method}(*args):
    return PythonGraphTraversal("__").${method}(*args)
""")
}; []
pythonClass.append("\n\n")

// save to a python file
file = new File("/Users/marko/Desktop/JYTHON-TUTORIAL/gremlin-python.py")
// file = new File("/usr/local/apache-gremlin-console-x.y.z-standalone/lib/gremlin-python.py")
file.delete()
pythonClass.eachLine{ file.append(it + "\n") }
----

When the above Groovy script is evaluated in GremlinConsole, **Gremlin-Python** is born.
The generated file is available at link:../../resources/gremlin-python.py[gremlin-python.py]. Now, from any Python
virtual machine (not just Jython), Gremlin traversals can be expressed in native Python and a legal Gremlin-Groovy
string is created behind the scenes.

[source,python]
----
Python 2.7.2 (default, Oct 11 2012, 20:14:37)
[GCC 4.2.1 Compatible Apple Clang 4.0 (tags/Apple/clang-418.0.60)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> execfile("/usr/local/apache-gremlin-console-x.y.z-standalone/lib/gremlin-python.py")
>>> g = PythonGraphTraversalSource("g")
# nested traversal with Python slicing and attribute interception extensions
>>> g.V().hasLabel("person").repeat(__.out()).times(2).name[0:2]
g.V().hasLabel("person").repeat(__.out()).times(2).values("name").range(0, 2)
>>> g.V().hasLabel("person").repeat(__.out()).times(2).name[0:2].toList()
[u'ripple', u'lop']
----

NOTE: The string that is generated for submission to a GremlinServer or `RemoteConnection` does not have to be a
Gremlin-Groovy string. However, it must be a string that has a respective `ScriptEngine` that is enabled on the remote
location. It is recommended that a Gremlin-Groovy string be constructed as Gremlin-Groovy is maintained by
Apache TinkerPop and is guaranteed to always be aligned with Gremlin-Java.