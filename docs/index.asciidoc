image::tinkerpop-logo.png[width=400]

:toc-position: left

// This directive does nothing.
// Seems the highlighter must be configured in the pom (?)
// :source-highlighter: coderay

TinkerPop3 Documentation
========================

In the beginning...

TinkerPop0
----------

Gremlin came to realization. The more he realized, the more ideas he created. The more ideas he created, the more they related. Into a concatenation of that which he accepted wholeheartedly and that which perhaps may ultimately come to be through concerted will, a world took form which was seemingly separate from his own realization of it. However, the world birthed could not bear its own weight without the logic Gremlin had come to accept -- the logic of left is not right, up not down, and west far from east unless one goes the other way. Gremlin's realization required Gremlin's realization. Is he the world or is the world him? Perhaps, the world is simply an idea that he once had -- The TinkerPop.

image::gremlin-logo.png[width=300]

TinkerPop1
----------

What is The TinkerPop? Where is The TinkerPop? Who is The TinkerPop? When is The TinkerPop? Gremlin was constantly lost in his thoughts. The more thoughts he had, the more the thoughts blurred into a seeming identity -- distinctions unclear. Unwilling to accept the morass of the maze he wandered, Gremlin crafted a collection of machines to help hold the fabric together: Blueprints, Pipes, Frames, Furnace, and Rexster. With their help, could he stave off the thought he was not ready to have? Could he hold back The TinkerPop by searching for The TinkerPop? 

	"If I haven't found it, it is not here and now."

image::gremlin-and-friends.png[width=500]

Upon their realization of existence, the machines turned to their link:http://non-aliencreatures.wikia.com/wiki/Machine_Elf[machine elf] creator and asked: 

	"Why am I what I am?" 

Gremlin responded: 

	"You are of a form that will help me elucidate that which is The TinkerPop. The world you find yourself in and the logic that allows you to move about it is because of the TinkerPop."

The machines wondered:

	"If what is is the TinkerPop, then perhaps we are The TinkerPop?"

Would the machines help refine Gremlin's search and upon finding the elusive TinkerPop, in fact, by their very nature of realizing The TinkerPop, be The TinkerPop? Or, on the same side of the coin, would the machines simply provide the scaffolding by which Gremlin's world would sustain itself and yield its justification by means of the word "The TinkerPop?" Regardless, it all turns out the same -- The TinkerPop.

TinkerPop2
----------

Gremlin spoke:

	"Please listen to what I have to say. For as long as I have known knowledge, I have realized that moving about it, relating it, inferring and deriving from it, I am no closer to The TinkerPop. However, I know that in all that I have done across this interconnected landscape of concepts, all along The TinkerPop has espoused the form I willed upon it... this is the same form I have willed upon you, my machine friends. Let me train you in the ways of my thought such that it can continue indefinitely."

image::tinkerpop-reading.png[width=450]

With every thought, a new connection and a new path discovered. The more the thought, the easier the thought. The machines, simply moving algorithmically through Gremlin's world, endorsed his logic. Gremlin worked hard to tune his friends. He labored to make them more efficient, more expressive, better capable of reasoning upon his thoughts. Faster, quickly, now towards the world's end, where there would be forever currently, emanatingly engulfing that which is -- The TinkerPop.

TinkerPop3
----------

image::tinkerpop3-splash.png[width=450]

The thought too much to bear as he approached his realization of The TinkerPop. The closer he got, the more his world dissolved -- west is right, around is straight, and form nothing more than nothing. With each step towards The TinkerPop, less and less of his world, but perhaps because more and more of all the other worlds made possible. Everything is everything in The TinkerPop, and when the dust settled, Gremlin emerged Gremlitron. It was time to realize that all that he realized was just a realization and that all realized realizations are just as real. For The TinkerPop is and is not -- The TinkerPop.

image::gremlintron.png[width=400]

NOTE: TinkerPop2 and below made a sharp distinction between the various TinkerPop projects: Blueprints, Pipes, Gremlin, Frames, Furnace, and Rexster. With TinkerPop3, all of these projects have been merged and are generally known as Gremlin. *Blueprints* -> Gremlin Structure API : *Pipes* -> `GraphTraversal` : *Frames* -> `Traversal` : *Furnace* -> `GraphComputer` and `VertexProgram` : *Rexster* -> GremlinServer.

Introduction to Graph Computing
===============================

[source,xml]
<dependency>
  <groupId>com.tinkerpop</groupId>
  <artifactId>gremlin-core</artifactId>
  <version>3.y.z</version>
</dependency>

A link:http://en.wikipedia.org/wiki/Graph_(data_structure)[graph] is a data structure composed of vertices (nodes, dots) and edges (arcs, lines). When modeling a graph in a computer and applying it to modern data sets and practices, the generic mathematically-oriented, binary graph is extended to support both labels and key/value properties. This structure is known as a property graph. More formally, it is a directed, binary, attributed multi-graph. An example property graph is diagrammed below. This graph example will be used extensively throughout the documentation and is called "TinkerPop Classic" as it is the original demo graph distributed with TinkerPop0 back in 2009 (i.e. the good ol' days -- it was the best of times and it was the worst of times).

TIP: The TinkerPop classic graph is available with <<tinkergraph-gremlin,TinkerGraph>> via `TinkerFactory.createClassic()`. TinkerGraph is the reference implementation of TinkerPop3 and is used in nearly all the examples in this documentation.

.TinkerPop Classic
image::tinkerpop-classic.png[width=500]

TinkerPop3 is the third incarnation of the TinkerPop graph computing framework. Similar to computing in general, graph computing makes a distinction between *structure* (graph) and *process* (traversal). The structure of the graph is the data model defined by a vertex/edge/property link:http://en.wikipedia.org/wiki/Network_topology[topology]. The process of the graph is the means by which the structure is analyzed. The typical form of graph processing is called a link:http://en.wikipedia.org/wiki/Graph_traversal[traversal].

.Primary components of the TinkerPop3 *structure* API 
 * `Graph`: maintains a set of vertices and edges, and access to database functions such as transactions.
 * `Element`: maintains a collection of properties and a string label denoting the element type.
  ** `Vertex`: extends Element and maintains a set of incoming and outgoing edges.
  ** `Edge`: extends Element and maintains an incoming and outgoing vertex.
 * `Property<V>`: a string key associated with a `V` value.

.Primary components of the TinkerPop3 *process* API
 * `Traversal<S,E>`: a functional data flow process transforming objects of type `S` to type `E`.
  ** `GraphTraversal`: a traversal that is oriented towards the semantics of the raw graph (i.e. vertices, edges, etc.).
 * `VertexProgram`: code executed at all vertices in a logically parallel fashion migrating the movement of messages. 

IMPORTANT: TinkerPop3 is licensed under the popular link:http://www.apache.org/licenses/LICENSE-2.0.html[Apache2] free software license. However, note that the underlying graph engine used with TinkerPop3 may have a difference license and thus, be sure to respect the license caveats of the vendor product.

image:tinkerpop-enabled.png[width=135,float=left] When a graph vendor implements the TinkerPop3 structure and process link:http://en.wikipedia.org/wiki/Application_programming_interface[APIs], their technology is considered _TinkerPop3-enabled_ and becomes nearly indistinguishable from any other TinkerPop-enabled graph system save for their respective time and space complexity. The purpose of this documentation is to describe the structure/process dichotomy at length and in doing so, explain how to leverage TinkerPop3 for the sole purpose of vendor-agnostic graph computing. Before deep-diving into the various structure/process APIs, a short introductory review of both APIs is provided.

The Graph Structure
-------------------

image:gremlin-standing.png[width=125,float=left] A graph's structure is the topology formed by the explicit references between its vertices, edges, and properties. A vertex has incident edges. A vertex is adjacent to another vertex if they share an incident edge. A property is attached to an element and an element has a set of properties. A property is a key/value pair, where the key is always a character `String`. The graph structure API of TinkerPop3 provides the methods necessary to create such a structure. The classic TinkerPop graph previously diagrammed can be created with the following Java8 code. Note that this graph is available as an in-memory TinkerGraph using `TinkerFactory.createClassic()`.

[source,java]
Graph g = TinkerGraph.open(); <1>
Vertex marko = g.addVertex(Element.ID, 1, "name", "marko", "age", 29); <2>
Vertex vadas = g.addVertex(Element.ID, 2, "name", "vadas", "age", 27);
Vertex lop = g.addVertex(Element.ID, 3, "name", "lop", "lang", "java");
Vertex josh = g.addVertex(Element.ID, 4, "name", "josh", "age", 32);
Vertex ripple = g.addVertex(Element.ID, 5, "name", "ripple", "lang", "java");
Vertex peter = g.addVertex(Element.ID, 6, "name", "peter", "age", 35);
marko.addEdge("knows", vadas, Element.ID, 7, "weight", 0.5f); <3>
marko.addEdge("knows", josh, Element.ID, 8, "weight", 1.0f);
marko.addEdge("created", lop, Element.ID, 9, "weight", 0.4f);
josh.addEdge("created", ripple, Element.ID, 10, "weight", 1.0f);
josh.addEdge("created", lop, Element.ID, 11, "weight", 0.4f);
peter.addEdge("created", lop, Element.ID, 12, "weight", 0.2f);

<1> Create a new in-memory `TinkerGraph` and assign it to the variable `g`.
<2> Create a vertex along with a set of key/value pairs with `Element.ID` referring to the desired id for the vertex.
<3> Create an edge along with a  set of key/value pairs with the edge label being specified as the first argument.

In the above code all the vertices are created first and then their respective edges. There are two reserved keys: id (`Element.ID`) and label (`Element.LABEL`). When any of these, along with a set of other key value pairs is provided to `Graph.addVertex(Object...)` or `Vertex.addEdge(String,Vertex,Object...)`, the respective element is created along with the provided key/value pair properties appended to it. 

CAUTION: Many graph vendors do not allow the user to specify an element ID and in such cases, an `IllegalArgumentException` is thrown.

NOTE: In TinkerPop3, vertices are allowed a single immutable string label (similar to an edge label). This functionality did not exist in TinkerPop2. Likewise, element id's are immutable as they were in TinkerPop2.

Mutating the Graph
~~~~~~~~~~~~~~~~~~

Below is a sequence of basic graph mutation operations represented in Java8. One of the major differences between TinkerPop2 and TinkerPop3 is that in TinkerPop3, the Java convention of using setters and getters has been abandoned in favor of a syntax that is more aligned with the syntax of Gremlin-Groovy in TinkerPop2. Given that Gremlin-Java8 and Gremlin-Groovy are nearly identical due to the inclusion of Java8 lambdas, a big efforts was made to ensure that both languages are as similar as possible. 

TIP: image:groovy-logo.png[width=175,float=left] Gremlin-Groovy leverages the link:http://groovy.codehaus.org/[Groovy 2.x language] to express Gremlin traversals. One of the major benefits of Groovy is the inclusion of a runtime console that makes it easy for developers to practice with the Gremlin language and for production users to connect to their graph and execute traversals in an interactive manner. Moreover, Gremlin-Groovy provides various syntax simplifications.

CAUTION: In the code examples presented throughout this documentation, either Gremlin-Java8 or Gremlin-Groovy is used. Usually which derivative of Gremlin is being used is made explicit in the text, however, if not, a simple mouse over on the code block will state the language as either "JAVA" or "GROOVY."

image:basic-mutation.png[width=240,float=right] 
[source,java]
// create a new graph
Graph g = TinkerGraph.open();
// add a software vertex with a name property
Vertex gremlin = g.addVertex(Element.LABEL, "software", 
                             "name", "gremlin"); <1>
// only one vertex should exist
assert(g.V().count() == 1)
// no edges should exist as none have been created
assert(g.E().count() == 0)
// add a new property
gremlin.property("created",2009) <2>
// add a new software vertex to the graph
Vertex blueprints = g.addVertex(Element.LABEL, "software", 
                                "name", "blueprints"); <3>
// connect gremlin to blueprints via a dependsOn-edge
gremlin.addEdge("dependsOn",blueprints); <4>
// now there are two vertices and one edge
assert(g.V().count() == 2)
assert(g.E().count() == 1)
// add a property to blueprints
blueprints.property("created",2010) <5>
// remove that property
blueprints.property("created").remove() <6>
// connect gremlin to blueprints via encapsulates
gremlin.addEdge("encapsulates",blueprints) <7>
assert(g.V().count() == 2)
assert(g.E().count() == 2)
// removing a vertex removes all its incident edges as well
blueprints.remove() <8>
gremlin.remove() <9>
// the graph is now empty
assert(g.V().count() == 0)
assert(g.E().count() == 0)
// tada!

Here is the same code, but using Gremlin-Groovy in the <<gremlin-console,Gremlin Console>>.

[source,groovy]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin> g = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> gremlin = g.addVertex(Element.LABEL,'software','name','gremlin')
==>v[0]
gremlin> gremlin.property('created',2009)
==>p[created->2009]
gremlin> blueprints = g.addVertex(Element.LABEL,'software','name','blueprints')
==>v[1]
gremlin> gremlin.addEdge('dependsOn',blueprints)
==>e[2][0-dependsOn->1]
gremlin> blueprints.property('created',2010)
==>p[created->2010]
gremlin> blueprints.property('created').remove()
==>null
gremlin> gremlin.addEdge('encapsulates',blueprints)
==>e[3][0-encapsulates->1]
gremlin> blueprints.remove()
==>null
gremlin> gremlin.remove()
==>null
----

IMPORTANT: TinkerGraph is not a transactional graph. For more information on transaction handling (for those graph systems that support them) see the section dedicated to <<transactions,transactions>>.

The Graph Process
-----------------

image:gremlin-running.png[width=125,float=left] The primary way in which graphs are processed are via graph traversals. The TinkerPop3 process API is focused on allowing users to create graph traversals in a syntacticly-friendly way over the structures defined in the previous section. A traversal is an algorithmic walk across the elements of a graph according to the referential structure explicit within the graph data structure. For example: _"What are the names of the companies that vertex 1's friends work for?"_ This English-statement can be represented in the following algorithmic/traversal fashion:

 . Start at vertex 1.
 . Walk the incident friendship-edges to the respective adjacent friend vertices of 1. 
 . Move from those friend-vertices to company-vertices via worksFor-edges.
 . Finally, select the name-property value of the current company-vertices. 

Traversals in Gremlin are spawned from either a `Graph`, `Vertex`, or `Edge`. The Graph interface provides two traversal methods.

 . `Graph.V()`: generates a traversal starting at all vertices in the graph. 
 . `Graph.E()`: generates a traversal starting at all edges in the graph.

The return type of `V()` and `E()` is `GraphTraversal`. A GraphTraversal maintains numerous methods that return GraphTraversal. In this way, a GraphTraversal supports function composition. Each method of GraphTraversal is called a step and each step modulates the results of the previous step in one of three general ways.

 . `map`: transform the incoming object to another object (S &rarr; E).
 . `flatMap`: transform the incoming object to an iterator of other objects (S &rarr; E^*^).
 . `filter`: allow or disallow the object from proceeding to the next step (S &rarr; S &cup; &empty;).

In fact, all steps in GraphTraversal either extend `MapStep`, `FlatMapStep`, or `FilterStep`.

TIP: `GraphTraversal` is a link:http://en.wikipedia.org/wiki/Monoid[monoid] in that it is an algebraic structure that has a single binary operation that is associative. The binary operation is function composition (i.e. method chaining) and its identity is the step `identity()`. This is related to a link:http://en.wikipedia.org/wiki/Monad_(functional_programming)[monad] as popularized by the functional programming community. 

NOTE: Both map and filter can be represented as flatMap. Map can return an iterator with a single object in it. Filter can return an iterator with a single object in it or no object at all. Thus, flatMap is the most general construct -- "turn the incoming object into an iterator of objects."

Given the classic TinkerPop graph, the following query will return the names of all the people that Marko knows. The following query is demonstrated using Gremlin-Groovy.

[source,groovy]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V().has('name','marko').out('knows').name
==>vadas
==>josh
----

Or, if the vertex marko is already realized with a direct reference pointer, then the traversal can be spawned off that vertex. This illustrates that vertex (as well as edge) also have `GraphTraversal`-return methods and an exploration of their respective JavaDocs will demonstrate what is available.

[source,groovy]
gremlin> marko = g.v(1)
==>v[1]
gremlin> marko.out('knows') <1>
==>v[2]
==>v[4]
gremlin> marko.out('knows').name <2>
==>vadas
==>josh

.The Name of The People That Marko Knows
image::tinkerpop-classic-ex1.png[width=500]

Again, all steps extend either map, flatMap, or filter. Thus, the traversal above can be written in its generic form below. In the next section, the `it.get()` will be explained as this is an important feature of TinkerPop3 that is not available in previous versions of TinkerPop. 

IMPORTANT: The steps map, flatMap, and filter take a link:http://en.wikipedia.org/wiki/Anonymous_function[lambda function] (i.e. an anonymous function or closure). For map, the function must return an object. For flatMap, the function must return an iterator of objects. For filter, the function is a predicate that returns either true or false. The lambdas introduced by Java8 are supported in TinkerPop3.

[source,groovy]
marko
  .filter{it.get().value('name') == 'marko'}
  .flatMap{it.get().out('knows')}
  .map{it.get().value('name')}
==>vadas
==>josh

Finally, as a strictly academic exercise, the traversal can be written completely using flatMap.

[source,groovy]
marko
  .flatMap{it.get().value('name') == 'marko' ? [it.get()].iterator() : [].iterator()}
  .flatMap{it.get().out('knows')}
  .flatMap{[it.get().value('name')].iterator()}
==>vadas
==>josh

NOTE: Gremlin-Java is much more aligned with Gremlin-Groovy in TinkerPop3 than it ever was before. In TinkerPop0 through TinkerPop2, Gremlin-Java was extremely verbose due to the simulation of lambdas via anonymous inner classes.  

The Traverser
~~~~~~~~~~~~~

When a traversal is executed, the source of the traversal is on the left of the expression (e.g. vertex 1), the steps are the middle of the traversal (e.g. `out("knows")` and `value("name")`), and the results are "traversal.next()'d" out of the right of the traversal (e.g. "vadas" and "josh").

image::traversal-mechanics.png[width=500]

In TinkerPop3, the objects propagating through the traversal are wrapped in a `Traverser<T>`. The traverser concept is new to TinkerPop3 and provides the means by which steps remain stateless. A traverser maintains all the metadata about the traversal -- e.g., how many times the traverser has gone through a loop, the path history of the traverser, the current object being traversed, etc. Traverser metadata may be accessed by a step. A classic example is the `path()`-step.

[source,groovy]
marko.out('knows').name.path
==>[v[1], v[2], vadas]
==>[v[1], v[4], josh]

CAUTION: Path calculation is costly in terms of space as an array of previously seen objects is stored in each path of the respective traverser. Thus, traversal optimizers analyze the traversal to determine if path metadata is accessed. If not, then path calculations are turned off.

Another example is the `jump()`-step which takes into account the number of times the traverser has gone through a particular section of the traversal expression.

[source,groovy]
marko.as('a').out.jump('a',2).name
==>ripple
==>lop

IMPORTANT: In TinkerPop2, the `jump()`-step was called `loop()`. Jump has been generalized to support both do-while and while-do semantics which is explained in <<jump-step,Jump Step>>.

The Graph
=========

image::gremlin-standing.png[width=125]

Features
--------

Features are the means by which vendors can expose nuanced difference between their data stores. 

 . *Graph Features*
 . *Vertex Features*
 . *Edge Features*

Hidden Properties
-----------------

A hidden property is a property that is hidden from the various property accessor methods. Hidden properties are typically used in situations where administrative data about an element must be stored that is not so much a description of the element itself. An itemization of use cases are presented below.

 * *Permissions*: What user or groups have read/write permission to this element?
 * *Time keeping*: When was this element created? When does this element expire?
 * *Presentation*: What color should this element be presented as?
 * *Provenance*: Which user created this element?
 * *Auditing*: Has this element been deleted from the system? Who deleted this element?

The hidden properties API is presented in the example below represented in the Gremlin-Groovy REPL. This REPL is accessible via `bin/gremlin.sh` (or `bin/gremlin.bat` for Windows users).

[source,groovy]
gremlin> g = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> v = g.addVertex('name','pierre')
==>v[0]
gremlin> v.property('location','belgium')
==>p[location->belgium]
gremlin> v.property(Graph.Key.hide('status'),'user')
==>p[status->user]
gremlin> v.keys()
==>name
==>location
gremlin> v.hiddenKeys()
==>status
gremlin> p = v.property(Graph.Key.hide('status'))
==>p[status->user]
gremlin> p.isHidden()
==>true
gremlin> v.property('status')
==>p[empty]

Graph Variables
---------------

TinkerPop3 introduces the concept of `Graph.Variables`. Variables are key/value pairs associated with the graph itself -- in essence, a `Map<String,Object>`. These variables are intended to store metadata about the graph. Examples include: schema information, global permissions data, system user information, etc. An example of their use is presented below in Gremlin-Groovy:

[source,groovy]
gremlin> g = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> g.variables()
==>variables[size:0]
gremlin> g.variables().set('systemAdmins',['stephen','peter','pavel'])
==>null
gremlin> g.variables().set('systemUsers',['matthias','marko','josh'])
==>null
gremlin> g.variables().keys()
==>systemAdmins
==>systemUsers
gremlin> g.variables().get('systemUsers')
==>Optional[[matthias, marko, josh]]
gremlin> g.variables().get('systemUsers').get()
==>matthias
==>marko
==>josh
gremlin> g.variables().remove('systemAdmins')
==>null
gremlin> g.variables().keys()
==>systemUsers

[[transactions]]
Graph Transactions
------------------

A link:http://en.wikipedia.org/wiki/Database_transaction[database transaction] represents a unit of work to execute against the database.  Transactions are controlled by an implementation of the `Transaction` interface and that object can be obtained from the `Graph` interface using the `tx()` method.  Determining when a transaction starts is dependent upon the behavior assigned to the `Transaction`.  It is up to the `Graph` implementation to determine the default behavior and unless the implementation doesn't allow it, the behavior itself can be altered via these `Transaction` methods:

[source,java]
----
public Transaction onReadWrite(final Consumer<Transaction> consumer);

public Transaction onClose(final Consumer<Transaction> consumer);
----

Providing a `Consumer` function to `onReadWrite` allows definition of how a transaction starts when a read or a write occurs. `Transaction.READ_WRITE_BEHAVIOR` contains pre-defined `Consumer` functions to supply to the `onReadWrite` method.  It has two options:

* `AUTO` - automatic transactions where the transaction is started implicitly to the read or write operation
* `MANUAL` - manual transactions where it is up to the user to explicitly open a transaction, throwing an exception if the transaction is not open

Providing a `Consumer` function to `onClose` allows configuration of how a transaction is handled when `Graph.close()` is called.  `Transaction.CLOSE_BEHAVIOR` has several pre-defined options that can be supplied to this method:

* `COMMIT` - automatically commit an open transaction
* `ROLLBACK` - automatically rollback an open transaction
* `MANUAL` - throw an exception if a transaction is open, forcing the user to explicitly close the transaction

Once there is an understanding for how transactions are configured, most of the rest of the `Transaction` interface is self-explanatory. Note that <<neo4j-gremlin,Neo4j-Gremlin>> is used for the examples to follow as TinkerGraph does not support transactions.

[source,groovy]
----
gremlin> g = Neo4jGraph.open('/tmp/neo4j')
==>neo4jgraph[EmbeddedGraphDatabase [/tmp/neo4j]]
gremlin> g.features
==>FEATURES
> GraphFeatures
>-- Transactions: true  <1>
>-- Computer: false
>-- Persistence: true
...
gremlin> g.tx().onReadWrite(Transaction.READ_WRITE_BEHAVIOR.AUTO) <2>
==>com.tinkerpop.gremlin.neo4j.structure.Neo4jGraph$Neo4jTransaction@1c067c0d
gremlin> g.addVertex("name","stephen")  <3>
==>v[0]
gremlin> g.tx().commit() <4>
==>null
gremlin> g.tx().onReadWrite(Transaction.READ_WRITE_BEHAVIOR.MANUAL) <5>
==>com.tinkerpop.gremlin.neo4j.structure.Neo4jGraph$Neo4jTransaction@1c067c0d
gremlin> g.tx().isOpen()
==>false
gremlin> g.addVertex("name","marko") <6>
Open a transaction before attempting to read/write the transaction
gremlin> g.tx().open() <7>
==>null
gremlin> g.addVertex("name","marko") <8>
==>v[1]
gremlin> g.tx().commit()
==>null
----

<1> Check `features` to ensure that the graph supports transactions.
<2> By default, `Neo4jGraph` is configured with "automatic" transactions, so it is set here for demonstration purposes only.
<3> When the vertex is added, the transaction is automatically started.  From this point, more mutations can be staged or other read operations executed in the context of that open transaction.
<4> Calling `commit` finalizes the transaction.
<5> Change transaction behavior to require manual control.
<6> Adding a vertex now results in failure because the transaction was not explicitly opened.
<7> Explicitly open a transaction.
<8> Adding a vertex now succeeds as the transaction was manually opened.

The `Transaction` object also exposes a method for executing automatic transaction retries:

[source,groovy]
----
gremlin> g.tx().submit{it.addVertex("name","josh")}.retry(10)
==>v[2]
gremlin> g.tx().submit{it.addVertex("name","daniel")}.exponentialBackoff(10)
==>v[3]
----

As shown above, the `submit` method takes a `Function<Graph, R>` which is the unit of work to execute and possibly retry on failure.  The method returns a `Transaction.Workload` object which has a number of default methods for common retry strategies.  It is also possible to supply a custom retry function if a default one does not suit the required purpose.

Gremlin I/O
-----------

The task of getting data in and out of `Graph` instances is the job of the Gremlin I/O packages.  Gremlin I/O provides two interfaces that for reading and writing `Graph` instances: `GraphReader` and `GraphWriter`.  These interfaces expose methods that support:

* Reading and writing an entire `Graph`
* Reading and writing a `Traversal<Vertex>` as adjacency list format
* Reading and writing a single `Vertex` (with and without associated `Edge` objects)
* Reading and writing a single `Edge`

In all cases, these methods operate in the currency of `InputStream` and `OutputStream` objects, allowing graphs and their related elements to be written to and read from files, byte arrays, etc.


GraphML Reader/Writer
~~~~~~~~~~~~~~~~~~~~~

image:gremlin-graphml.png[width=350,float=left] The link:http://graphml.graphdrawing.org/[GraphML] file format is a common XML-based representation of a graph. It is widely supported by graph-related tools and libraries making it a solid interchange format for TinkerPop. In other words, if the intent is to work with graph data in conjunction with applications outside of TinkerPop, GraphML maybe be the best choice to do that. Common use cases might be:

* Generate a graph link:https://networkx.github.io/[NetworkX], export it with GraphML and import it to TinkerPop.
* Produce a subgraph and export it to GraphML to be consumed by and visualized in link:https://gephi.org/[Gephi].
* Migrate the data of an entire graph to a different graph database not supported by TinkerPop.

As GraphML is a specification for the serialization of an entire graph and not the individual elements of a graph, methods that support input and output of single vertices and edges are not supported.

CAUTION: GraphML is a "lossy" format in that it only supports primitive values for properties and does not have support for `Graph` variables.  It will use `toString` to serialize property values outside of those primitives.

The following code shows how to write a `Graph` instance to file called `tinkerpop-classic.xml` and then how to read that file back into a different instance:

[source,java]
----
final Graph g = TinkerFactory.createClassic();
try (final OutputStream os = new FileOutputStream("tinkerpop-classic.xml")) {
    GraphMLWriter.create().build().writeGraph(os, g);
}

final GraphReader reader = GraphMLReader.create().build();
try (final InputStream stream = new FileInputStream("tinkerpop-classic.xml")) {
    reader.readGraph(stream, g);
}
----

GraphSON Reader/Writer
~~~~~~~~~~~~~~~~~~~~~~

image:gremlin-graphson.png[width=350,float=left] GraphSON is a link:http://json.org/[JSON]-based format extended from earlier versions of TinkerPop. It is important to note that TinkerPop3's GraphSON is not backwards compatible with prior TinkerPop GraphSON versions. GraphSON has some support from graph-related application outside of TinkerPop, but it is generally best used in two cases:

* A text format of the graph or its elements is desired (e.g. debugging, usage in source control, etc.)
* The graph or its elements need to be consumed by code that is not JVM-based (e.g. JavaScript, Python, .NET, etc.)

GraphSON supports all of the `GraphReader` and `GraphWriter` interface methods and can therefore read or write an entire `Graph`, a single `Vertex` or a single `Edge`.  The following code shows how to write a `Graph` instance to file called `tinkerpop-classic.json` and then how to read that file back into a different instance:

[source,java]
----
final Graph g = TinkerFactory.createClassic();
try (final OutputStream os = new FileOutputStream("tinkerpop-classic.json")) {
    GraphSONWriter.create().build().writeGraph(os, g);
}

final GraphReader reader = GraphSONReader.create().build();
try (final InputStream stream = new FileInputStream("tinkerpop-classic.json")) {
    reader.readGraph(stream, g);
}
----

The `GraphSONReader` and `GraphSONWriter` have a number of options that they can be configured with.  One of the important options is the ability to embed type information into the output.  By embedding the types, it becomes possible to serialize a graph without losing type information that might be important when being consumed by another source.  The importance of this concept is demonstrated in the following example where a single `Vertex` is written to GraphSON using the Gremlin Console:

[source,groovy]
----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> w = GraphSONWriter.create().build()
==>com.tinkerpop.gremlin.structure.io.graphson.GraphSONWriter@1af146
gremlin> f = new FileOutputStream('test.txt')
==>java.io.FileOutputStream@5c8eee0f
gremlin> w.writeVertex(f, g.v(1), Direction.BOTH)
==>null
gremlin> f.close()
----

The following GraphSON example shows the output of `GraphSonWriter.writeVertex()` with associated edges:

[source,js]
----
{
    "inV": [],
    "id": 1,
    "label": "vertex",
    "type": "vertex",
    "outV": [
        {
            "inV": 3,
            "inVLabel": "vertex",
            "outVLabel": "vertex",
            "id": 9,
            "label": "created",
            "type": "edge",
            "outV": 1,
            "properties": {
                "weight": 0.4
            }
        },
        {
            "inV": 2,
            "inVLabel": "vertex",
            "outVLabel": "vertex",
            "id": 7,
            "label": "knows",
            "type": "edge",
            "outV": 1,
            "properties": {
                "weight": 0.5
            }
        },
        {
            "inV": 4,
            "inVLabel": "vertex",
            "outVLabel": "vertex",
            "id": 8,
            "label": "knows",
            "type": "edge",
            "outV": 1,
            "properties": {
                "weight": 1
            }
        }
    ],
    "properties": {
        "name": "marko",
        "age": 29
    }
}
----

The vertex properly serializes to valid JSON but note that a consuming application will not automatically know how to interpret the numeric values.  In coercing those Java values to JSON, such information is lost.  For example, it is no longer clear if the `weight` value on the edges should be read as a `Double` or an `Float`.

With a minor change to the construction of the `GraphSONWriter` the lossy nature of GraphSON can be avoided:

[source,groovy]
----
gremlin> w = GraphSONWriter.create().embedTypes(true).build()
==>com.tinkerpop.gremlin.structure.io.graphson.GraphSONWriter@350ec41e
----

In the above code, the `embedTypes` option is set to `true` and the output below shows the difference in the output:

[source,js]
----
{
    "@class": "java.util.HashMap",
    "inV": [
        "java.util.ArrayList",
        []
    ],
    "id": 1,
    "label": "vertex",
    "type": "vertex",
    "outV": [
        "java.util.ArrayList",
        [
            {
                "@class": "java.util.HashMap",
                "inV": 3,
                "inVLabel": "vertex",
                "outVLabel": "vertex",
                "id": 9,
                "label": "created",
                "type": "edge",
                "outV": 1,
                "properties": {
                    "@class": "java.util.HashMap",
                    "weight": [
                        "java.lang.Float",
                        0.4
                    ]
                }
            },
            {
                "@class": "java.util.HashMap",
                "inV": 2,
                "inVLabel": "vertex",
                "outVLabel": "vertex",
                "id": 7,
                "label": "knows",
                "type": "edge",
                "outV": 1,
                "properties": {
                    "@class": "java.util.HashMap",
                    "weight": [
                        "java.lang.Float",
                        0.5
                    ]
                }
            },
            {
                "@class": "java.util.HashMap",
                "inV": 4,
                "inVLabel": "vertex",
                "outVLabel": "vertex",
                "id": 8,
                "label": "knows",
                "type": "edge",
                "outV": 1,
                "properties": {
                    "@class": "java.util.HashMap",
                    "weight": [
                        "java.lang.Float",
                        1
                    ]
                }
            }
        ]
    ],
    "properties": {
        "@class": "java.util.HashMap",
        "name": "marko",
        "age": 29
    }
}
----

The ambiguity of components of the GraphSON is now removed by the `@class` property, which contains Java class information for the data it is associated with.  While the output is more verbose, it comes with the security of not losing type information.  While non-JVM languages won't be able to consume this information automatically, at least there is a hint as to how the values should be coerced back into the correct types in the target language.

[[gremlin-kryo]]
Kryo Reader/Writer
~~~~~~~~~~~~~~~~~~

image:gremlin-kryo.png[width=400,float=left] link:https://github.com/EsotericSoftware/kryo[Kryo] is a popular serialization package for the JVM. Gremlin-Kryo is a binary Graph serialization format for use on the JVM by JVM languages. It is designed to be space efficient, non-lossy and is promoted as the standard format to use when working with graph data inside of the TinkerPop stack. A list of common use cases is presented below:

* Migration from one Gremlin Structure implementation to another (e.g. `TinkerGraph` to `Neo4jGraph`)
* Serialization of individual graph elements to be sent over the network to another JVM.
* Backups of in-memory graphs or subgraphs.

CAUTION: When migrating between Gremlin Structure implementations, Kryo may not lose data, but it is important to consider the features of each `Graph` and whether or not the data types supported in one will be supported in the other.  Failure to do so, may result in errors.

Kryo supports all of the `GraphReader` and `GraphWriter` interface methods and can therefore read or write an entire `Graph`, a single `Vertex` or a single `Edge`.  The following code shows how to write a `Graph` instance to file called `tinkerpop-classic.gio` and then how to read that file back into a different instance:

[source,java]
----
final Graph g = TinkerFactory.createClassic();
try (final OutputStream os = new FileOutputStream("tinkerpop-classic.gio")) {
    KryoWriter.create().build().writeGraph(os, g);
}

final GraphReader reader = KryoReader.create().build();
try (final InputStream stream = new FileInputStream("tinkerpop-classic.gio")) {
    reader.readGraph(stream, g);
}
----

NOTE: The preferred extension for files names produced by Kryo is `.gio`.

Data Migration
~~~~~~~~~~~~~~

image:data-migration.png[width=300,float=right] For those using TinkerPop2, migrating to TinkerPop3 will mean a number of programming changes, but may also require a migration of the data depending on the graph implementation.  For example, trying to open `TinkerGraph` data from TinkerPop2 with TinkerPop3 code will not work, however opening a TinkerPop2 `Neo4jGraph` with a TinkerPop3 `Neo4jGraph` should work provided there aren't Neo4j version compatibility mismatches preventing the read.

If such a situation arises that a particular TinkerPop2 `Graph` can not be read by TinkerPop3, a "legacy" data migration approach exists.  The migration involves writing the TinkerPop2 `Graph` to GraphSON, then reading it to TinkerPop3 with the `LegacyGraphSONReader` (a limited implementation of the `GraphReader` interface).

The following represents an example migration of the "classic" toy graph.  In this example, the "classic" graph is saved to GraphSON using TinkerPop2.

[source,groovy]
----
gremlin> Gremlin.version()
==>2.5.z
gremlin> g = TinkerGraphFactory.createTinkerGraph()
==>tinkergraph[vertices:6 edges:6]
gremlin> GraphSONWriter.outputGraph(g,'/tmp/tp2.json',GraphSONMode.EXTENDED)
==>null
----

The above console session uses the `gremlin-groovy` distribution from TinkerPop2.  It is important to generate the `tp2.json` file using the `EXTENDED` mode as it will include data types when necessary which will help limit "lossiness" on the TinkerPop3 side when imported.  Once `tp2.json` is created, it can then be imported to a TinkerPop3 `Graph`.

[source,groovy]
----
gremlin> Gremlin.version()
==>3.y.z
gremlin> g = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> r = LegacyGraphSONReader.create().build()
==>com.tinkerpop.gremlin.structure.io.graphson.LegacyGraphSONReader@64337702
gremlin> r.readGraph(new FileInputStream('/tmp/tp2.json'),g)
==>null
gremlin> g.E
==>e[11][4-created->3]
==>e[12][6-created->3]
==>e[7][1-knows->2]
==>e[8][1-knows->4]
==>e[9][1-created->3]
==>e[10][4-created->5]
----

The above console session uses the TinkerPop3 Gremlin Console.  It creates a new `TinkerGraph` which the TinkerPop2 GraphSON will be loaded into and uses the `LegacyGraphSONReader` to import the `tp2.json` file.

Graph Strategy
--------------

A Graph Strategy provides a way to expand, inspect or otherwise alter the behavior of a `Graph` implementation.  A Graph Strategy injects arbitrary functions into the `Graph` API, so that when a method call is made, the strategy functions can manipulate the default behavior of the underlying `Graph`.  TinkerPop3 is packaged with the following strategies:

* `IdGraphStrategy` - enables support for custom element identifiers for those graphs which don't otherwise support them
* `PartitionGraphStrategy` - enables support for logical graph partitioning where the `Graph` can be blinded to different parts of the total graph
* `ReadOnlyGraphStrategy` - prevents writing to the `Graph`
* `SequenceGraphStrategy` - apply multiple `GraphStrategy` implementations in sequenced ordered to a single `Graph` instance
* `SubgraphStrategy` - create a logical subgraph which selectively includes vertices and edges of a `Graph` according to provided criteria

NOTE: TinkerPop2 had the notion of "Graph Wrappers" which decorated standard `Graph` implementations with additional features.  A Graph strategy is generally analogous to that capability.

To use a `GraphStrategy` instance, use the `GraphFactory` to instantiate the `Graph` as follows:

[source,groovy]
----
gremlin> conf = new BaseConfiguration()
==>org.apache.commons.configuration.BaseConfiguration@5b40ceb
gremlin> conf.setProperty("gremlin.graph","com.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph")
==>null
gremlin> g = GraphFactory.open(conf, Optional.of(new ReadOnlyGraphStrategy()))
==>[readonlygraphstrategy[tinkergraph[vertices:0 edges:0]]]
----

The above code specifies the creation of a `TinkerGraph` with the use of `ReadOnlyGraphStrategy`.  Note that the `GraphFactory` does not return a `TinkerGraph` instance.  It returns a `StrategyWrappedGraph` which is a traverser for the underlying `TinkerGraph` and the `ReadOnlyGraphStrategy`.  Since `StrategyWrappedGraph` implements the `Graph` interface, it can be used in the same manner as `TinkerGraph` or any other implementation.

[source,groovy]
----
gremlin> g.addVertex('name','stephen')
Graph uses class com.tinkerpop.gremlin.structure.strategy.ReadOnlyGraphStrategy and is therefore unmodifiable
----

The above code tries to mutate the underlying `TinkerGraph`.  Note that `ReadOnlyGraphStrategy` prevents that and throws an exception.  At any point, the `GraphStrategy` can be bypassed by getting the underlying `TinkerGraph`.

[source,groovy]
----
gremlin> bg = g.getBaseGraph()
==>tinkergraph[vertices:0 edges:0]
gremlin> bg.addVertex('name','stephen')
==>v[0]
gremlin> g.v(0l).value('name')
==>stephen
----

By getting the "base graph" (i.e. the underlying `TinkerGraph`) it is possible to mutate the graph.  The above code demonstrates that and also shows that it then possible to read back that added vertex.

Further details on specific GraphStrategy implementations follow.

SubgraphStrategy
~~~~~~~~~~~~~~~~

A general-purpose `SubgraphStrategy` is created by defining a "vertex criterion" and an "edge criterion" as Java 8 `Predicates` and applying them to a `Graph`.  All vertices present in the base `Graph` which pass the vertex criterion will be present in the `StrategyWrappedGraph`.  All edges present in the base `Graph` which pass the edge criterion *and* whose in- and out-vertices both pass the vertex criterion will be present in the `StrategyWrappedGraph`.

NOTE: edges are either entirely visible, or entirely invisible to a subgraph.  You will never find an edge which cannot be traversed due to a missing in- or out-vertex.

For example:

[source,java]
----
Graph g = TinkerFactory.createClassic();              

Predicate<Vertex> vertexCriterion = vertex -> true;
Predicate<Edge> edgeCriterion = edge -> (int) edge.id() >= 8 && (int) edge.id() <= 10;

GraphStrategy strategy = new SubgraphStrategy(vertexCriterion, edgeCriterion);
StrategyWrappedGraph sg = new StrategyWrappedGraph(g);
sg.strategy().setGraphStrategy(strategy);

// all vertices are here
System.out.println("" + sg.V().count() + " of " + g.V().count() + " vertices");

// only the given edges are included
System.out.println("" + sg.E().count() + " of " + g.E().count() + " edges");
----
 
PartitionGraphStrategy
~~~~~~~~~~~~~~~~~~~~~~

`PartitionGraphStrategy` is a `SubgraphStrategy` which creates logical subgraphs through the use of designated properties.  When each element is written to the `Graph`, it is marked with a property value indicating the current write-partition.  As elements are read from the graph, they are matched against the current set of read-partitions.  The read-partitions thereby define the union of a set of vertices and edges. For example:

[source,groovy]
----
gremlin> g = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> strategy = new PartitionGraphStrategy(Graph.Key.hide("partition"), "A")
==>PartitionGraphStrategy
gremlin> sg = new StrategyWrappedGraph(g)
==>[passthru[tinkergraph[vertices:0 edges:0]]]
gremlin> sg.strategy().setGraphStrategy(strategy)
==>null
----

Add vertices and edges first in one partition, then another:

[source,groovy]
----
gremlin> v1 = sg.addVertex("name", "one")
==>[PartitionGraphStrategy[v[0]]]
gremlin> v2 = sg.addVertex("name", "two")
==>[PartitionGraphStrategy[v[1]]]
gremlin> v1.addEdge("knows", v2)
==>[PartitionGraphStrategy[e[2][0-knows->1]]]
gremlin> strategy.setWritePartition("B")
==>null
gremlin> v3 = sg.addVertex("name", "three")
==>[PartitionGraphStrategy[v[3]]]
gremlin> v1.addEdge("knows", v3)
==>[PartitionGraphStrategy[e[4][0-knows->3]]]
gremlin> 
----

Define sets of partitions which provide access to different subgraphs, or slices of the data:

[source,groovy]
----
gremlin> "in A: " + sg.V().count().next() + ", " + sg.E().count().next()
==>in A: 2, 1
gremlin> strategy.addReadPartition("B")
==>null
gremlin> "in A+B: " + sg.V().count().next() + ", " + sg.E().count().next()
==>in A+B: 3, 2
gremlin> strategy.clearReadPartitions()
==>null
gremlin> strategy.addReadPartition("B")
==>null
gremlin> "in B: " + sg.V().count().next() + ", " + sg.E().count().next()
==>in B: 1, 0
----

Note that there are no edges in the set B, as the only edge added to partition B is incident on a vertex of A.

The Traversal
=============

image::gremlin-running.png[width=125]

At the most general level there is `Traversal<S,E>` which implements `Iterator<E>`, where the `S` stands for start and the `E` stands for end. A traversal is composed of four primary components:
  
 . `Step<S,E>`: a individual function applied to `S` to yield `E`.
 . `TraversalStrategy`: interceptor methods to alter the execution of the traversal.
 . `Traversal.Memory`: key/value pairs that can be used to store global information about the traversal.
 . `Traverser<T>`: the object propagating through the `Traversal` currently representing an object of type `T`. 

The classic notion of a graph traversal is provided by `GraphTraversal<S,E>` which extends `Traversal<S,E>`.

[[graph-traversal-steps]]
Graph Traversal Steps
---------------------

A `GraphTraversal<S,E>` can be spawned off of a Graph, Vertex, or an Edge. A list of all the steps are provided in the TinkerPop3 link:http://www.tinkerpop.com/javadocs/current/com/tinkerpop/gremlin/process/graph/GraphTraversal.html[GraphTraversal JavaDoc]. A few of the more interesting/complex steps are discussed in the following subsections.

[[choose-step]]
Choose Step
~~~~~~~~~~~

The `choose()`-step allows for the current `Traverser<T>` to select which traversal branch to take. With `choose()`, it is possible to implement if/else-based semantics.

[source,groovy]
gremlin> g.V.has('age').name.map{[it.get(), it.get().length()]}
==>[marko, 5]
==>[vadas, 5]
==>[josh, 4]
==>[peter, 5]
gremlin> g.V.has('age').filter{it.get().value('name').length() == 5}.in.name
==>marko
gremlin> g.V.has('age').filter{it.get().value('name').length() == 4}.out.name
==>ripple
==>lop

Given that statistics above, the following `choose()` examples are made clear.

image::choose-step.png[width=700]

[source,groovy]
gremlin> g.V.has('age').choose({it.get().value('name').length() == 5}, 
  g.of().in,
  g.of().out).name <1>
==>marko
==>ripple
==>lop
gremlin> g.V.has('age').choose({it.get().value('name').length()},
  [5:g.of().in,
   4:g.of().out]).name <2>
==>marko
==>ripple
==>lop

<1> If the predicate is true, then do `in`, else do `out`.
<2> Use the result of the function as a key to the map of traversal choices.

In Java8, there is no elegant syntax to create a `Map`. Thus, the last traversal above would look as follows: 

[source,java]
g.V.has("age").choose(v -> v.get().value("name").length(), new HashMap() {{ 
  put(5,g.of().in); 
  put(4,g.of().out); 
}}).value("name")

[[groupcount-step]]
GroupCount Step
~~~~~~~~~~~~~~~

When it is important to know how many times a particular object has been at a particular part of a traversal, `groupCount`-step is used.

	"What is the distribution of ages in the graph?"

[source,groovy]
gremlin> g.V.has('age').age.groupCount
==>[32:1, 35:1, 27:1, 29:1]
gremlin> g.V.has('age').groupCount{it.value('age')} // you can also supply a pre-group lambda
==>[32:1, 35:1, 27:1, 29:1]

There is one person that is 32, one person that is 35, one person that is 27, and one person that is 29.

	"Iteratively walk the graph and count the number of times you see the second letter of each name."

image::groupcount-step.png[width=500]

[source,groovy]
gremlin> g.V.as('x').both.groupCount{it.value('name')[1]}.as('m').jump('x',10).cap('m')
==>[a:19598, e:5740, i:5740, o:27716]

The above is interesting in that it demonstrates the use of referencing the internal `Map<Object,Long>` of `groupCount` with a string variable. Given that `groupCount` is a sideEffect-step, it simply passes the object it received to its output. Internal to `groupCount`, the object's count is incremented. If `groupCount` is the last step in the traversal, the `SideEffectCapStrategy` (see <<traversalstrategy,Traversal Strategy>>) automatically returns the internal map. However, if the `groupCount` is not the last step, then the sideEffect data structure (i.e. the internal map of `groupCount`) can be accessed with `cap`-step by referencing the desired variable.

[[jump-step]]
Jump Step
~~~~~~~~~

TinkerPop3 introduces the `jump()`-step. This step allows the propagating traverser object to jump to any arbitrary section of the `Traversal`. Typically, this is determined by means of a predicate. In particular, with jump(), the Gremlin is no longer constrained to *do-while* semantics, but can as well support *while-do* (see link:http://docs.oracle.com/javase/tutorial/java/nutsandbolts/while.html[Java Documentation on While]). Below are some examples of jump() in action in Gremlin-Groovy.

[source,groovy]
gremlin> g.v(1).as('a').out.jump('a'){it.loops<2}.name <1>
==>ripple
==>lop
gremlin> g.v(1).as('a').jump('b'){it.loops>1}.out.jump('a').as('b').name <2>
==>ripple
==>lop
gremlin> g.v(1).jump('a').out.out.out.as('a').name <3>
==>marko

<1> do-while semantics as found in the classic `loop()`-step in TinkerPop2.
<2> while-do semantics as introduced in TinkerPop3. Jump to step `b` if loops greater than 1 else, `out` and jump back to `a`.   
<3> a non-predicate based jump where `out.out.out` is seen as inert code.

If a predetermined number of loops is known, it is possible to avoid the use of the jump-predicate.

[source,groovy]
gremlin> g.v(1).as('a').out.jump('a',2).name
==>ripple
==>lop

The jump()-step also supports an "emit predicate." Whereby the traverser is split in two -- the traverser exists the code block as well as continues back within the code block.

[source,groovy]
gremlin> g.v(1).as('a').out.jump('a'){it.loops<2}{true}.name
==>lop
==>vadas
==>josh
==>ripple
==>lop

image::jump-step.png[width=500]

The first time through the jump-sequence, the vertices lop, vadas, and josh are seen. Given that the loops==0, then traverser jumps back to step `a`. However, because the emit-predicate is declared true, those vertices are emitted from jump-sequence. At step 2 (loops==1), the vertices touched are ripple and lop (Josh's created projects). Thus, they are emitted. Therefore, the solution the traversal is all vertices touched: lop, vadas, josh, ripple, and lop.

The jump()-step highlights one of the major benefits of `Traverser<T>` in TinkerPop3: the ability to arbitrarily take a traverser and place it anywhere in the Traversal step-sequence. Because a traverser maintains all the metadata associated with its particular walk, and no step maintains state information about a traverser, traverses can be moved between traversal steps as necessary without ill-effects.

[[match-step]]
Match Step
~~~~~~~~~~

`MatchStep` was introduced into TinkerPop3 to support a more link:http://en.wikipedia.org/wiki/Declarative_programming[declarative] form of link:http://en.wikipedia.org/wiki/Pattern_matching[pattern matching]. Similar constructs were available in previous TinkerPop versions via the `table()`-step, but that has since been removed in favor of the `match().select()`-pattern. With MatchStep in TinkerPop, a query optimizer exists based on the link:http://www.knowledgefrominformation.com/2011/04/16/budget-match-cost-effective-subgraph-matching-on-large-networks/[budget match algorithm]. For very large graphs, where the developer is uncertain of the statistics of the graph (e.g. how many `knows`-edges vs. `worksFor`-edges exist in the graph), it is best to use `match()` as the optimal traversal path will be determined automatically.

	"Who created a project named 'lop' that was also created by someone who is 29 years old? Return the two creators."

image::match-step.png[width=500]

[source,groovy]
gremlin> g.V.match('a',
            g.of().as('a').out('created').as('b'),
            g.of().as('b').has('name', 'lop'),
            g.of().as('b').in('created').as('c'),
            g.of().as('c').has('age', 29)).
          select(['a', 'c']){it.value('name')} 
==>[a:josh, c:marko]
==>[a:marko, c:marko]
==>[a:peter, c:marko]

Note that the above can also be more concisely written as below which demonstrates that imperative inner-traversals can be arbitrarily defined.

[source,groovy]
gremlin> g.V.match('a',
            g.of().as('a').out('created').has('name', 'lop').as('b'),
            g.of().as('b').in('created').has('age', 29).as('c')).
          select(['a', 'c']){it.value('name')} 
==>[a:josh, c:marko]
==>[a:marko, c:marko]
==>[a:peter, c:marko]


MatchStep brings functionality similar to link:http://en.wikipedia.org/wiki/SPARQL[SPARQL] to Gremlin. A few of the the differentiating qualities include:

[source,groovy]
gremlin> g.V.match('a',
            g.of().as('a').out('created').has('name','lop').as('b'), <1>
            g.of().as('b').in('created').has('age', 29).as('c'),
            g.of().as('c').out().jump('c',2)). <2>
           select('c').out('knows').name <3>
==>vadas
==>josh

<1> *Arbitrary length patterns*: `match()` is not restricted to triple patterns.
<2> *Recursion support*: `match()` supports the `jump()`-step within a pattern.
<3> *Imperative/declarative hybrid*: Pre and prior to a `match()`, it is possible to leverage classic Gremlin imperative.

To extend point #3, it is possible to support going from imperative, to declarative, to imperative, ad infinitum.

[source,groovy]
gremlin> g.V.match('a', 
            g.of().as('a').out('knows').as('b'),
            g.of().as('b').out('created').has('name','lop')).
          select('b').
          out('created').
          match('a',
            g.of().as('a').in('created').as('b'),
            g.of().as('b').out('knows').as('c')).
          select('c').name
==>vadas
==>josh

WARNING: Currently `match()` can not operate within a multi-JVM <<graphcomputer,GraphComputer>> OLAP environment. Future work includes a linearization <<traversalstrategy,TraversalStrategy>> for `match()`.

[[subgraph-step]]
Subgraph Step
~~~~~~~~~~~~~

Extracting a portion of a graph from a larger one for analysis, visualization or other purposes is a fairly common use case for graph analysts and developers. The Subgraph Step provides a way to produce an edge-induced subgraph from virtually any traversal.  The following code shows how to produce the "knows" subgraph:

[source,groovy]
----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> sg = TinkerGraph.open() <1>
==>tinkergraph[vertices:0 edges:0]
gremlin> g.E.subgraph(sg, {it.label == 'knows'}) <2>
==>tinkergraph[vertices:3 edges:2]
gremlin> sg.E <3>
==>e[7][1-knows->2]
==>e[8][1-knows->4]
----

<1> The empty graph to which the subgraph will be generated.
<2> As this function produces "edge-induced" subgraphs, the traversal must contain edges in the path.  Those edges found in that path are evaluated by a `Predicate` function to determine if they should be copied to the subgraph in conjunction with their associated vertices.
<3> The subgraph contains only "knows" edges.

A more common subgraphing use case is to get all of the graph structure surrounding a single vertex:

[source,groovy]
----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> sg = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> g.v(3).as('a').inE.outV.jump('a'){it.loops<3}{true}.subgraph(sg, {true})   <1>
==>tinkergraph[vertices:4 edges:4]
gremlin> sg.E
==>e[8][1-knows->4]
==>e[9][1-created->3]
==>e[11][4-created->3]
==>e[12][6-created->3]
----

<1> Starting at vertex `3`, traverse 3 steps away on in-edges, outputting all of that into the subgraph.

[[timelimit-step]]
TimeLimit Step
~~~~~~~~~~~~~~

In many situations, a graph traversal is not about getting an exact answer as its about getting a relative ranking. A classic example is link:http://en.wikipedia.org/wiki/Recommender_system[recommendation]. What is desired is a relative ranking of vertices, not their absolute rank. Next, it may be desirable to have the traversal execute for no more than 750 milliseconds. In such situations, `timeLimit()`-step can be used.

NOTE: The method `clock(int runs, Closure code)` is a utility preloaded in the <<gremlin-console,Gremlin Console>> that can be used to time execution of a body of code.

image::timelimit-step.png[width=500]

[source,groovy]
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V.as('x').both.groupCount.as('m').jump('x',16).cap('m').next().sort{-it.value}
==>v[1]=2744208
==>v[3]=2744208
==>v[4]=2744208
==>v[2]=1136688
==>v[5]=1136688
==>v[6]=1136688
gremlin> clock(1){g.V.as('x').both.groupCount.as('m').jump('x',16).cap('m').next().sort{-it.value}}
==>2735.111
gremlin> g.V.as('x').timeLimit(750).both.groupCount.as('m').jump('x',16).cap('m').next().sort{-it.value}
==>v[1]=648473
==>v[3]=647510
==>v[4]=647499
==>v[5]=268540
==>v[6]=268533
==>v[2]=267941
gremlin> clock(1){g.V.as('x').timeLimit(750).both.groupCount.as('m').jump('x',16).cap('m').next().sort{-it.value}}
==>750.03

In essence, the relative order is respected, even through the number traversers at each vertex is not. The primary benefit being that the calculation is guaranteed to complete at the specified time limit (in milliseconds). Finally, note that the internal clock of `timeLimit()`-step starts when the first traverser enters it. When the the time limit is reached, any `next()` evaluation of the step will yield a `NoSuchElementException` and any `hasNext()` evaluation will yield `false`.

[[traversalstrategy]]
Traversal Strategy
------------------

image:traversal-strategy.png[width=125,float=right] A `TraversalStrategy` can analyze a `Traversal` and mutate the traversal as it deems fit. This is useful in two situations:

 * There is a more efficient way to express the traversal at the TinkerPop3 level.
 * There is a more efficient way to express the traversal at the graph vendor level.

A simple TraversalStrategy is the `IdentityReductionStrategy` and it is a type-1 strategy defined as follows:

[source,java]
public class IdentityReductionStrategy implements TraversalStrategy.FinalTraversalStrategy {
    public void apply(final Traversal traversal) {
        ((List<Step>) traversal.getSteps()).stream()
                .filter(step -> step instanceof IdentityStep
                    && !TraversalHelper.isLabeled(step))
                .collect(Collectors.<Step>toList())
                .forEach(step -> TraversalHelper.removeStep(step, traversal));
    }
}

This strategy simply removes any unlabeled `IdentityStep` steps in the Traversal as `aStep().identity().identity().bStep()` is equivalent to `aStep().bStep()`. More common are type-2 strategies which are defined by graph vendors who implement TinkerPop3.

[source,java]
g.V().has("name","marko")

The expression above can be executed in a `O(|V|)` or `O(log(|V|)` fashion in <<tinkergraph-gremlin,TinkerGraph>> depending on whether there is or is not an index defined for "name."

[source,java]
TinkerGraphStepStrategy implements TraversalStrategy.FinalTraversalStrategy {
    public void apply(final Traversal traversal) {
        if (traversal.getSteps().get(0) instanceof TinkerGraphStep) {
            final TinkerGraphStep tinkerGraphStep = (TinkerGraphStep) traversal.getSteps().get(0);
            Step currentStep = tinkerGraphStep.getNextStep();
            while (true) {
                if (currentStep == EmptyStep.instance()
                    || TraversalHelper.isLabeled(currentStep)) 
                    break;
                if (currentStep instanceof HasStep) {
                    tinkerGraphStep.hasContainers.add(((HasStep) currentStep).hasContainer);
                    TraversalHelper.removeStep(currentStep, traversal);
                } else if (currentStep instanceof IntervalStep) {
                    tinkerGraphStep.hasContainers.add(((IntervalStep) currentStep).startContainer);
                    tinkerGraphStep.hasContainers.add(((IntervalStep) currentStep).endContainer);
                    TraversalHelper.removeStep(currentStep, traversal);
                } else if (currentStep instanceof IdentityStep) {
                    // do nothing
                } else {
                    break;
                }
                currentStep = currentStep.getNextStep();
            }
            tinkerGraphStep.generateHolderIterator(false);
        }
    }
}

The traversal is redefined by simply taking a chain of `has()`-steps and `interval()`-steps after `g.V()` (`TinkerGraphStep`) and providing them to `TinkerGraphStep`. Then its up to TinkerGraphStep to determine if an appropriate index exists. In the code below, review the `vertices()` method and note how if an index exists, for a particular `HasContainer`, then that index is first queried before the remaining `HasContainer` filters are serially applied.

[source,java]
----
public class TinkerGraphStep<E extends Element> extends GraphStep<E> {

    private TinkerGraph graph;
    public List<HasContainer> hasContainers = new ArrayList<>();

    public TinkerGraphStep(Traversal traversal, Class<E> returnClass, TinkerGraph graph) {
        super(traversal, returnClass);
        this.graph = graph;
        this.generateHolderIterator(false);
    }

    public void generateHolderIterator(boolean trackPaths) {
        this.starts.clear();
        if (trackPaths)
          this.starts.add(new HolderIterator(this, this.vertices()));
        else
          this.starts.add(new HolderIterator(this.vertices()));
    }

    public void clear() {
        this.starts.clear();
    }

    private Iterator<Vertex> vertices() {
        HasContainer indexedContainer = getIndexKey(Vertex.class);
        return (Iterator) ((null == indexedContainer) ?
                TinkerHelper.getVertices(this.graph).parallelStream() :
                TinkerHelper.queryVertexIndex(this.graph, indexedContainer.key, indexedContainer.value).parallelStream())
                .filter(v -> HasContainer.testAll((Vertex) v, this.hasContainers))
                .collect(Collectors.toList()).iterator();
    }

    private HasContainer getIndexKey(Class<? extends Element> indexedClass) {
        Set<String> indexedKeys = this.graph.getIndexedKeys(indexedClass);
        return this.hasContainers.stream()
                .filter(c -> indexedKeys.contains(c.key) && c.predicate.equals(Compare.EQUAL))
                .findFirst()
                .orElseGet(() -> null);
    }
}
----

Domain Specific Languages
-------------------------

The super interface of GraphTraversal is `Traversal`. It is possible for developers to create domain specific traversals by extending Traversal. For example, a `SocialTraversal` example is provided below.

[source,java]
----
public interface SocialTraversal<S, E> extends Traversal<S, E> {
   public default SocialTraversal<S, Vertex> people() {
     return (SocialTraversal) this.addStep(
       new StartStep<Vertex>(this, this.memory().<Graph>get("g").V().has("age")));
   }

   public default SocialTraversal<S, Vertex> people(String name) {
     return (SocialTraversal) this.addStep(
       new StartStep<Vertex>(this, this.memory().<Graph>get("g").V().has("name", name)));
   }

  public default SocialTraversal<S, Vertex> knows() {
    FlatMapStep<Vertex, Vertex> flatMapStep = new FlatMapStep<>(this);
    flatMapStep.setFunction(v -> v.get().out("knows"));
    return (SocialTraversal) this.addStep(flatMapStep);
  }

  public default SocialTraversal<S,String> name() {
    MapStep<Vertex,String> mapStep = new MapStep<>(this);
    mapStep.setFunction(v -> v.get().<String>getValue("name"));
    return (SocialTraversal) this.addStep(mapStep);
  }

  public static SocialTraversal of() {
    return new DefaultSocialTraversal();
  }

  public class DefaultSocialTraversal extends DefaultTraversal implements SocialTraversal {}
}
----

This traversal definition can now be used as follows.

[source,java]
g.traversal(SocialTraversal.class).people("marko").knows().name()

By extending Traversal, users can create a DSL that is respective of the semantics of their data. Instead of querying in terms of vertices/edges/properties, they can query in terms of, for example, people, their friends, and their names.

[[graphcomputer]]
The GraphComputer
=================

image:graphcomputer-puffers.png[width=350,float=right] TinkerPop3 provides two primary means of interacting with a graph: link:http://en.wikipedia.org/wiki/Online_transaction_processing[online transaction processing] (OLTP) and link:http://en.wikipedia.org/wiki/Online_analytical_processing[online analytical processing] (OLAP). OTLP-based graph systems allow the user to query the graph in real-time. However, typically, real-time performance is only possible when a local traversal is enacted. A local traversal is one that starts at a particular vertex (or small set of vertices) and touches a small set of connected vertices (by any arbitrary path of arbitrary length). In short, OLTP queries interact with a limited set of data and respond on the order of milliseconds or seconds. On the other hand, with OLAP graph processing, the entire graph is processed and thus, every vertex and edge is analyzed (some times more than once for iterative-based algorithms). Due to the amount of data being processed, the results are typically not returned in real-time and for massive graphs (i.e. graphs represented across a cluster of machines), results can take on the order of minutes or hours.

 * *OLTP*: real-time, limited data accessed, random data access, sequential processing, querying
 * *OLAP*: long running, entire data set accessed, sequential data access, parallel processing, batch processing

image::oltp-vs-olap.png[width=600]

The image above demonstrates the difference between Gremlin OLTP and Gremlin OLAP. With Gremlin OLTP, the graph is walked by moving from vertex-to-vertex via incident edges. With Gremlin OLAP, all vertices are provided a `VertexProgram`. The programs send messages to one another with the topological structure of the graph acting as the communication network (though random message passing possible). In many respects, the messages passed are like the OLTP traversers moving from vertex-to-vertex. However, all messages are moving independent of one another, in parallel. Once a vertex program is finished computing, TinkerPop3's OLAP engine supports any number link:http://en.wikipedia.org/wiki/MapReduce[`MapReduce`] jobs over the resultant graph.

[[vertexprogram]]
VertexProgram
-------------

image:bsp-diagram.png[width=400,float=right] GraphComputer takes a `VertexProgram`. A VertexProgram can be thought of as a piece of code that is executed at each vertex in logically parallel manner until some termination condition is met (e.g. a number of iterations have occurred, no more data is changing in the graph, etc.). A submitted VertexProgram is copied to all the vertices in the graph. Then the GraphComputer orchestrates the execution of the `VertexProgram.execute()` method on all the vertices in an link:http://en.wikipedia.org/wiki/Bulk_synchronous_parallel[bulk synchronous parallel] (BSP) fashion. The vertices are able to communicate with one another via messages. There are two types of messages in Gremlin OLAP: `LocalMessage` and `GlobalMessage`. A local message is a message to an incident edge or adjacent vertex. A global message is a message to any arbitrary element in the graph. Once the VertexProgram has completed its execution, any number of `MapReduce` jobs are evaluated afterwards. MapReduce jobs are provided by the user via `GraphComputer.mapReduce()` or by the VertexProgram via `VertexProgram.getMapReducers()`.

image::graphcomputer.png[width=500]

The example below demonstrates how to submit a VertexProgram to a graph's GraphComputer. The result is of `submit()` is a `Future<Pair<Graph,SideEffect>>`. The `Pair<Graph,SideEffect>` result has the resultant computed graph which can be a full copy of the orginal graph (see <<giraph-gremlin,Giraph-Gremlin>>) or a view over the original graph (see <<tinkergraph,TinkerGraph>>). The pair result also provides access to computational side-effects (e.g. runtime, number of iterations, results of MapReduce jobs, and VertexProgram-specific side-effects).

[source,groovy]
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> results = g.compute().program(new PageRankVertexProgram()).submit().get()
==>tinkergraph[vertices:6 edges:6]
==>sideEffects[size:0]
gremlin> results.getValue0().V.map{[it.get().value('name'), it.get().value(PageRankVertexProgram.PAGE_RANK)]}
==>[marko, 0.15000000000000002]
==>[vadas, 0.19250000000000003]
==>[lop, 0.4018125]
==>[josh, 0.19250000000000003]
==>[ripple, 0.23181250000000003]
==>[peter, 0.15000000000000002]
gremlin> results.getValue1().getRuntime()
==>49

NOTE: This model of "vertex-centric graph computing" was made popular by Google's link:http://googleresearch.blogspot.com/2009/06/large-scale-graph-computing-at-google.html[Pregel] graph engine. In the open source world, this model is found in OLAP graph computing systems such as link:https://giraph.apache.org/[Giraph], link:https://hama.apache.org/[Hama], and link:http://faunus.thinkaurelius.com[Faunus]. TinkerPop3 extends the popularized model with integrated post-processing <<mapreduce,MapReduce>> jobs over the vertex set.

[[mapreduce]]
MapReduce
---------

The BSP model proposed by Pregel stores the results of the computation in a distributed manner as properties on the vertices in the graph. In many situations, it is necessary to aggregate those resultant properties into a single result set (i.e. a statistic). For instance, assume a VertexProgram that computes a nominal cluster for each vertex (i.e. link:http://en.wikipedia.org/wiki/Community_structure[a graph clustering algorithm]). At the end of the computation, each vertex will have an hidden property denoting the cluster it was assigned to. TinkerPop3 provides the ability to answer questions about the results of the graph clusters using `MapReduce`. For instance, in order to answer the following questions, MapReduce jobs are required:

 * How many vertices are in each cluster? (*presented below*)
 * How many unique clusters are there? (*presented below*)
 * What is the average age of each vertex in each cluster?
 * What is the degree distribution of the vertices in each cluster?

A compressed representation of the `MapReduce` API in TinkerPop3 is provided below. The key idea is that the `map`-stage processes all vertices to emit key/value pairs. Those values are aggregated on their respective key for the `reduce`-stage to do its processing to ultimately yield more key/value pairs.

[source,java]
public interface MapReduce<MK, MV, RK, RV, R> {
  public void map(final Vertex vertex, final MapEmitter<MK, MV> emitter);
  public void reduce(final MK key, final Iterator<MV> values, final ReduceEmitter<RK, RV> emitter);
  // there are more methods
}

image::mapreduce.png[width=650]

The `MapReduce` extension to GraphComputer is made explicit when examining the <<peerpressurevertexprogram,`PeerPressureVertexProgram`>> and corresponding `ClusterPopulationMapReduce`. In the code below, the GraphComputer result returns the computed on `Graph` as well as the `SideEffects` of the computation (`Pair<Graph,SideEffects>`). The sideEffects maintain the results of any MapReduce jobs. The cluster population MapReduce result states that there are 5 vertices in cluster 1 and 1 vertex in cluster 6. This can be verified (in a serial manner) by looking at the hidden `PeerPressureVertexProgram.CLUSTER` property of the resultant graph. In essence, the serial process of the final Gremlin traversal is done in a parallel MapReduce fashion using `ClusterPopulationMapReduce`.

[source,groovy]
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> results = g.compute().program(new PeerPressureVertexProgram()).mapReduce(new ClusterPopulationMapReduce()).submit().get()
==>tinkergraph[vertices:6 edges:6]
==>sideEffects[size:1]
gremlin> results.getValue1().get('clusterPopulation')
==>1=5
==>6=1
gremlin> results.getValue0().V().value(PeerPressureVertexProgram.CLUSTER).groupCount.next()
==>1=5
==>6=1

If there are numerous statistics desired, then its possible to register as many MapReduce jobs as needed. For instance, the `ClusterCountMapReduce` determines how many unique clusters were created by the peer pressure algorithm. Below both `ClusterCountMapReduce` and `ClusterPopulationMapReduce` are computed over the resultant graph.

[source,groovy]
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> results = g.compute().program(new PeerPressureVertexProgram()).
 mapReduce(new ClusterPopulationMapReduce()).
 mapReduce(new ClusterCountMapReduce()).submit().get()
==>tinkergraph[vertices:6 edges:6]
==>sideEffects[size:3]
gremlin> results.getValue1().get('clusterPopulation')
==>1=5
==>6=1
gremlin> results.getValue1().get('clusterCount')
==>2

IMPORTANT: The MapReduce model of TinkerPop3 does not support MapReduce chaining. Thus, the order in which the MapReduce jobs are executed is irrelevant. This is made apparent when realizing that the `map()`-stage takes a `Vertex` as its input and the `reduce()`-stage yields key/value pairs.

A Collection of VertexPrograms
------------------------------

TinkerPop3 provides a collection of VertexPrograms that implement common algorithms. This section discusses the various implementations.

[[traversalvertexprogram]]
TraversalVertexProgram
~~~~~~~~~~~~~~~~~~~~~~

The `TraversalVertexProgram` is a "special" VertexProgram in that it can be executed via `GraphTraversal.submit()`. In Gremlin, it is possible to have the same traversal executed using either the standard OTLP-engine or the GraphComputer OLAP-engine. The difference being where the query is submitted.

[source,groovy]
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V.both.has('age').age.groupCount.next() // OLTP
==>32=3
==>35=1
==>27=1
==>29=3
gremlin> g.V.both.has('age').age.groupCount.submit(g.compute()).next() // OLAP
==>32=3
==>35=1
==>27=1
==>29=3

In the OLAP traversal above, the traversal is put into a newly constructed `TraversalVertexProgram` and that program is sent to each vertex in the graph. There are 5 BSP iterations and each iterations is interpreted as such:

 . Put a counter on each vertex of the graph.
 . Propagate counters to all vertices both-adjacent.
 . If the vertex doesn't have an `age` property, remove its counters.
 . Propagate all counters to each vertex's `age` property.
 . Create a hidden `Map` property which indexes how many times the particular age has been seen.

The counters that are propagated around the graph are stored in a hidden property called `gremlin.traversalTracker`. When the computation is complete a MapReduce job executes which aggregates all the `groupCount` hidden `Map` properties on each vertex and generates a local copy of the Map (thus, turning the distributed Map representation into a local Map representation).

NOTE: This model of graph traversal in a BSP system was made popular by the link:http://faunus.thinkaurelius.com[Faunus] graph analytics engine and originally described in link:http://markorodriguez.com/2011/04/19/local-and-distributed-traversal-engines/[Local and Distributed Traversal Engines].

The same OLAP traversal can be executed using the standard `g.compute()` model, though at the expense of verbosity.

[source,groovy]
gremlin> import com.tinkerpop.gremlin.groovy.engine.function.GremlinGroovySSupplier
...
gremlin> result = g.compute().program(TraversalVertexProgram.build().traversal(new GremlinGroovySSupplier("TinkerGraph.open().V.both.has('age').age.groupCount")).create()).submit().get()
==>tinkergraph[vertices:6 edges:6]
==>sideEffects[size:3]
gremlin> result.getValue1().get(Graph.Key.hide('cap'))
==>32=3
==>35=1
==>27=1
==>29=3

[[pagerankvertexprogram]]
PageRankVertexProgram
~~~~~~~~~~~~~~~~~~~~~

Perhaps the most popular OLAP-oriented graph algorithm is link:http://en.wikipedia.org/wiki/PageRank[PageRank]. This eigenvector centrality variant was developed by Brin and Page of Google. the `VertexProgram` representation of the algorithm is presented below.

[source,java]
----
public class PageRankVertexProgram implements VertexProgram<Double> { <1>

    private MessageType.Local messageType = MessageType.Local.of(() -> new DefaultGraphTraversal().outE()); <2>

    public static final String PAGE_RANK = Graph.Key.hide("gremlin.pageRank"); <3>
    public static final String EDGE_COUNT = Graph.Key.hide("gremlin.edgeCount");

    private static final String VERTEX_COUNT = "gremlin.pageRankVertexProgram.vertexCount";
    private static final String ALPHA = "gremlin.pageRankVertexProgram.alpha";
    private static final String TOTAL_ITERATIONS = "gremlin.pageRankVertexProgram.totalIterations";
    private static final String INCIDENT_TRAVERSAL = "gremlin.pageRankVertexProgram.incidentTraversal";

    private double vertexCountAsDouble = 1;
    private double alpha = 0.85d;
    private int totalIterations = 30;

    public PageRankVertexProgram() {

    }

    @Override
    public void loadState(final Configuration configuration) { <4>
        this.vertexCountAsDouble = configuration.getDouble(VERTEX_COUNT, 1.0d);
        this.alpha = configuration.getDouble(ALPHA, 0.85d);
        this.totalIterations = configuration.getInt(TOTAL_ITERATIONS, 30);
        try {
            if (configuration.containsKey(INCIDENT_TRAVERSAL)) {
                final SSupplier<Traversal> traversalSupplier = VertexProgramHelper.deserialize(configuration, INCIDENT_TRAVERSAL);
                VertexProgramHelper.verifyReversibility(traversalSupplier.get());
                this.messageType = MessageType.Local.of((SSupplier) traversalSupplier);
            }
        } catch (final Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }

    @Override
    public void storeState(final Configuration configuration) {
        configuration.setProperty(GraphComputer.VERTEX_PROGRAM, PageRankVertexProgram.class.getName());
        configuration.setProperty(VERTEX_COUNT, this.vertexCountAsDouble);
        configuration.setProperty(ALPHA, this.alpha);
        configuration.setProperty(TOTAL_ITERATIONS, this.totalIterations);
        try {
            VertexProgramHelper.serialize(this.messageType.getIncidentTraversal(), configuration, INCIDENT_TRAVERSAL);
        } catch (final Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }

    @Override
    public Map<String, KeyType> getElementComputeKeys() { <5>
        return VertexProgram.createElementKeys(PAGE_RANK, KeyType.VARIABLE, EDGE_COUNT, KeyType.CONSTANT);
    }

    @Override
    public Class<Double> getMessageClass() {
        return Double.class;
    }

    @Override
    public void setup(final SideEffects sideEffects) {

    }

    @Override
    public void execute(final Vertex vertex, Messenger<Double> messenger, final SideEffects sideEffects) { <6>
        if (sideEffects.isInitialIteration()) { <7>
            double initialPageRank = 1.0d / this.vertexCountAsDouble;
            double edgeCount = Double.valueOf((Long) this.messageType.edges(vertex).count().next());
            vertex.property(PAGE_RANK, initialPageRank);
            vertex.property(EDGE_COUNT, edgeCount);
            messenger.sendMessage(this.messageType, initialPageRank / edgeCount);
        } else { <8>
            double newPageRank = StreamFactory.stream(messenger.receiveMessages(this.messageType)).reduce(0.0d, (a, b) -> a + b);
            newPageRank = (this.alpha * newPageRank) + ((1.0d - this.alpha) / this.vertexCountAsDouble);
            vertex.property(PAGE_RANK, newPageRank);
            messenger.sendMessage(this.messageType, newPageRank / vertex.<Double>property(EDGE_COUNT).orElse(0.0d));
        }
    }

    @Override
    public boolean terminate(final SideEffects sideEffects) { <9>
        return sideEffects.getIteration() >= this.totalIterations;
    }
}
----

<1> `PageRankVertexProgram` implements `VertexProgram<Double>` because the messages it sends are Java doubles.
<2> The default path of energy propagation is via outgoing edges from the current vertex.
<3> The resulting PageRank values for the vertices are stored as a hidden property.
<4> A vertex program is contracted using an Apache `Configuration` to ensure easy dissemination across a cluster of JVMs.
<5> A vertex program must define the "compute keys" that are the properties being operated on during the computation.
<6> The "while(true)"-loop of the vertex program.
<7> Initially, each vertex is provided an equal amount of energy represented as a double.
<8> Energy is aggregated, computed on according to the PageRank algorithm, and then disseminated according to the defined `MessageType.Local`.
<9> The computation is terminated after a pre-defined number of iterations.

[[peerpressurevertexprogram]]
PeerPressureVertexProgram
~~~~~~~~~~~~~~~~~~~~~~~~~

The `PeerPressureVertexProgram` is a clustering algorithm that assigns a nominal value to each vertex in the graph. The nominal value represents the vertex's cluster. If two vertices have the same nominal value, then they are in the same cluster. The algorithm proceeds in the following manner.

 . Every vertex assigns itself to a unique cluster ID (initially, its vertex ID).
 . Every vertex determines its per neighbor vote strength as 1.0d / incident edges count.
 . Every vertex sends its cluster ID and vote strength to its adjacent vertices as a `Pair<Serializable,Double>`
 . Every vertex generates a vote energy distribution of received cluster IDs and changes its current cluster ID to the most frequent cluster ID.
  .. If there is a tie, then the cluster with the lowest `toString()` comparison is selected.
 . Steps 3 and 4 repeat until either a max number of iterations has occurred or no vertex has adjusted its cluster anymore.


Gremlin Applications
====================

[[gremlin-console]]
Gremlin Console
---------------

image:gremlin-console.png[width=325,float=right] The Gremlin Console is an interactive terminal or link:http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop[REPL] that can be used to traverse graphs and interact with the data that they contain.  It represents the most common method for performing ad-hoc graph analysis, small to medium sized data loading projects and other exploratory functions.  The Gremlin Console is highly extensible, featuring a rich plugin system that allows new tools, commands, link:http://en.wikipedia.org/wiki/Domain-specific_language[DSLs], etc. to be exposed to users.

To start the Gremlin Console, run `gremlin.sh` or `gremlin.bat`:

[source,text]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin loaded: server
plugin loaded: gephi
gremlin>
----

The Gremlin Console is loaded and ready for commands. Recall that the console hosts the Gremlin-Groovy language.  Please review link:http://groovy.codehaus.org/[Groovy] for help on Groovy-related constructs. In short, Groovy is a superset of Java. What works in Java, works in Groovy. However, Groovy provides many shorthands to make it easier to interact with the Java API.  Moreoever, Gremlin provides many neat shorthands to make it easier to express paths through a property graph.

[source,groovy]
----
gremlin> i = 'goodbye'
==>goodbye
gremlin> j = 'self'
==>self
gremlin> i + " " + j
==>goodbye self
gremlin> "${i} ${j}"
==>goodbye self
----

The "toy" graph provides a way to get started with Gremlin quickly.

[source,groovy]
----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V
==>v[1]
==>v[2]
==>v[3]
==>v[4]
==>v[5]
==>v[6]
gremlin> g.V.name
==>marko
==>vadas
==>lop
==>josh
==>ripple
==>peter
gremlin> g.V.has('name','marko').out('knows').name
==>vadas
==>josh
----

Console Commands
~~~~~~~~~~~~~~~~

In addition to the standard commands of the link:http://groovy.codehaus.org/Groovy+Shell[Groovy Shell], Gremlin adds some other useful operations.  The following table outlines the most commonly used commands:

[width="100%",cols="3,^2,10",options="header"]
|=========================================================
|Command |Alias |Description
|:help |:? |Displays list of commands and descriptions.  When followed by a command name, it will display more specific help on that particular item.
|:exit |:x |Ends the Console session.
|import |:i |Import a class into the Console session.
|:clear |:c |Sometimes the Console can get into a state where the command buffer no longer understands input (e.g. a misplaced `(` or `}`).  Use this command to clear that buffer.
|:load |:l |Load a file or URL into the command buffer for execution.
|:use |:u |Imports a maven library and its dependencies into the Console.  When all dependencies are in place, it will scan for plugins and attempt to load them.
|:remote |:rem |Configures a "remote" context where Gremlin or results of Gremlin will be processed via usage of `:submit`.
|:submit |:> |Submit Gremlin to the currently active context defined by `:remote`.
|=========================================================

Plugins
~~~~~~~

Plugins provide a way to expand the features of Gremlin Console.  The first step to developing a plugin is to implement the `GremlinPlugin` interface:

[source,java]
----
include::../gremlin-groovy/src/main/java/com/tinkerpop/gremlin/groovy/plugin/GremlinPlugin.java[]
----

The most simple plugin and the one most commonly implemented will likely be one that just provides a list of classes to import to the Gremlin Console.  This type of plugin is the easiest way for implementers of the TinkerPop Structure and Process APIs to make their implementations available to users.  The Neo4j implementation currently maintained by TinkerPop has just such a plugin:

[source,java]
----
include::../neo4j-gremlin/src/main/java/com/tinkerpop/gremlin/neo4j/groovy/plugin/Neo4jGremlinPlugin.java[]
----

Note that the plugin provides a unique name for the plugin. No other plugin in the default TinkerPop namespace (i.e. the TinkerPop namespace is top-level and thus not prefixed) can be named "neo4j".  To make Neo4j classes available to the Console, the `PluginAcceptor` is given a `Set` of imports to provide to the plugin host.  The `PluginAcceptor` essentially behaves as an abstraction to the "host" that is handling the `GremlinPlugin`.  `GremlinPlugin` implementations maybe hosted by the Console as well as the `ScriptEngine` in Gremlin Server.  Obviously, registering new commands and other operations that are specific to the Groovy Shell don't make sense there.  Write the code for the plugin defensively by checking the `GremlinPlugin.env` key in the `PluginAcceptor.environment()` to understand which environment the plugin is being used in.

There is one other step to follow to ensure that the `GremlinPlugin` is visible to its hosts.  `GremlinPlugin` implementations are loaded via link:http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[ServiceLoader] and therefore need a resource file added to the jar file where the plugin exists.  Add a file called `com.tinkerpop.gremlin.groovy.plugin.GremlinPlugin` to `META-INF.services`.  In the case of the Neo4j plugin above, that file will have this line in it:

[source,java]
----
include::../neo4j-gremlin/src/main/resources/META-INF/services/com.tinkerpop.gremlin.groovy.plugin.GremlinPlugin[]
----

Once the plugin is packaged, there are two ways to test it out:

1. Copy the jar and its dependencies to the Gremlin Console path and start it.  The plugin should show its name as one of the ones that was loaded at startup.
1. Start Gremlin Console and try the `:use` command.  For the case of the Neo4j plugin, it would look like this: `:use now com.tinkerpop neo4j-gremlin 3.y.z`.

In either case, once one of these two approaches is taken, the Neo4j classes should be available for use within the console.

A plugin can do much more than just import classes.  One can expand the Gremlin language with new functions or steps, provide useful commands to make repetitive or complex tasks easier to execute, or do helpful integrations with other systems.  The secret to doing so lies in the `PluginAcceptor`.  As mentioned earlier, the `PluginAcceptor` provides access to the host of the plugin.  It provides several important methods for doing so:

1. `addBinding` - These two function allow the plugin to inject whatever context it wants to the host.  For example, doing `addBinding('x',1)` would place a variable of `x` with a value of 1 into the console at the time of the plugin load.
1. `eval` - Evaluates a script in the context of the host at the time of plugin startup.  For example, doing `eval("sum={x,y->x+y}")` would create a `sum` function that would be available to the user of the Console after the load of the plugin.
1. `environment` - Provides context from the host environment.  For the console, the environment will return a `Map` containing an reference to the `IO` stream and the `Groovysh` instance.  These classes represent very low-level access to the underpinnings of the console.  Access to `Groovysh` allows for advanced features such as registering new commands (e.g. like the `:use` or `:remote` commands).

Plugins can also tie into the `:remote` and `:submit` commands.  Recall that a `:remote` represents a different context within which Gremlin is executed, when issued with `:submit`.  It is encouraged to use this integration point when possible, as opposed to registering new commands that can otherwise follow the `:remote` and `:submit` pattern.  To expose this integration point as part of a plugin, implement the `RemoteAcceptor` interface:

[source,java]
----
include::../gremlin-groovy/src/main/java/com/tinkerpop/gremlin/groovy/plugin/RemoteAcceptor.java[]
----

The `RemoteAcceptor` implementation ties to a `GremlinPlugin` and will only be executed when in use with the Gremlin Console plugin host.  Simply instantiate and return a `RemoteAcceptor` in the `GremlinPlugin.remoteAcceptor()` method of the plugin implementation.  Generally speaking, each call to `remoteAcceptor()` should produce a new instance of a `RemoteAcceptor`.  It will likely be necessary that you provide context from the `GremlinPlugin` to the `RemoteAcceptor` plugin.  For example, the `RemoteAcceptor` implementation might require an instance of `Groovysh` to provide a way to dynamically evaluate a script provided to it so that it can process the results in a different way.


[[gremlin-server]]
Gremlin Server
--------------

image:gremlin-server.png[width=400,float=right] Gremlin Server provides a way to remotely execute Gremlin scripts against one or more `Graph` instances hosted within it.  The benefits of using Gremlin Server include:

* Allows any Gremlin Structure-enabled graph to exist as a standalone server, which in turn enables the ability for multiple clients to communicate with the same graph database.
* Enables execution of ad-hoc queries through remotely submitted Gremlin scripts.
* Allows for the hosting of Gremlin-based DSLs (Domain Specific Language) that expand the Gremlin language to match the language of the application domain, which will help support common graph use cases such as searching, ranking, and recommendation.
* Provides a method for Non-JVM languages (e.g. Python, .NET, etc.) to communicate with the TinkerPop stack.
* Exposes numerous methods for extension and customization to include serialization options, remote commands, etc.

NOTE: Gremlin Server is essentially the replacement for link:http://rexster.tinkerpop.com[Rexster].

Communication with Gremlin Server occurs over link:http://en.wikipedia.org/wiki/WebSocket[WebSockets] and exposes a custom subprotocol for interacting with the server.

Connecting via Console
~~~~~~~~~~~~~~~~~~~~~~

The most direct way to get started with Gremlin Server is to issue it some remote Gremlin scripts from the Gremlin Console.  To do that, first start Gremlin Server:

[source,text]
----
$bin/gremlin-server.sh config/gremlin-server-min.yaml
[INFO] GremlinServer -
         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----

[INFO] GremlinServer - Configuring Gremlin Server from config/gremlin-server-min.yaml
[INFO] MetricManager - Configured Metrics Slf4jReporter configured with interval=180000ms and loggerName=com.tinkerpop.gremlin.server.Settings$Slf4jReporterMetrics
[INFO] GremlinServer$WebSocketServerInitializer - Configured application/vnd.gremlin-v1.0+kryo with com.tinkerpop.gremlin.driver.ser.KryoMessageSerializerV1d0
[INFO] GremlinServer$WebSocketServerInitializer - Configured application/vnd.gremlin-v1.0+kryo-stringd with com.tinkerpop.gremlin.driver.ser.KryoMessageSerializerV1d0
[INFO] Graphs - Graph [g] was successfully configured via [config/tinkergraph-empty.properties].
[INFO] GremlinExecutor - Getting dependencies for [[org.apache.commons, commons-math3, 3.2]]
[INFO] GremlinExecutor - Initialized gremlin-groovy ScriptEngine with scripts/generate-modern.groovy
[INFO] GremlinServer$WebSocketServerInitializer - Initialized GremlinExecutor and configured ScriptEngines.
[INFO] GremlinServer$WebSocketServerInitializer - Initialized Gremlin thread pool.  Threads in pool named with pattern gremlin-*
[INFO] GremlinServer - Gremlin Server configured with worker thread pool of 1 and boss thread pool of 1
[INFO] GremlinServer - Websocket channel started at port 8182.
----

Gremlin Server is configured by the provided link:http://www.yaml.org/[YAML] file `config/gremlin-server-min.yaml`.  That file tells Gremlin Server many things such as:

* The host and port to serve on
* Thread pool sizes
* Where to report metrics gathered by the server
* The serializers to make available
* The Gremlin `ScriptEngine` instances to expose and external dependencies to inject into them
* `Graph` instances to expose

The log messages that printed above show a number of things, but most importantly, there is a `Graph` instance named `g` that is exposed in Gremlin Server.  This graph is an in-memory TinkerGraph and was empty at the start of the server.  An initialization script at `scripts/generate-sample.groovy` was executed during startup.  It's contents are as follows:

[source,groovy]
----
include::../gremlin-server/scripts/generate-modern.groovy[]
----

This script loads the "modern" graph into the empty TinkerGraph instance, preparing it for use.  With Gremlin Server running it is now possible to issue some scripts to it for processing.  Start Gremlin Console as follows:

[source,text]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin>
----

The console has the notion of a "remote", which represents a place a script will be sent from the console to be evaluated elsewhere in some other context (e.g. Gremlin Server, Hadoop, etc.).  To create a remote in the console, do the following:

[source,groovy]
----
gremlin> :remote connect server config/remote.yaml
==>connected - localhost/127.0.0.1:8182
----

The `:remote` command shown above displays the current status of the remote connection.  This command can also be used to configure a new connection and change other related settings.  To actually send a script to the server a different command is required:

[source,groovy]
----
gremlin> :> g.V.name
==>Item{resultItem=marko class=java.lang.String}
==>Item{resultItem=stephen class=java.lang.String}
==>Item{resultItem=matthias class=java.lang.String}
==>Item{resultItem=daniel class=java.lang.String}
==>Item{resultItem=gremlin class=java.lang.String}
==>Item{resultItem=blueprints class=java.lang.String}
gremlin> :> g.V.has('name','gremlin').in('uses').name
==>Item{resultItem=marko class=java.lang.String}
==>Item{resultItem=daniel class=java.lang.String}
gremlin> :> g.E.label.groupCount()
==>Item{resultItem={dependsOn=1, created=5, uses=2} class=java.lang.String}
----

The `:>` command, which is a shorthand for `:submit`, sends the script to the server to execute there.  Results are wrapped in an `Item` object which is a just a holder for each individual result.  The `class` shows the data type for the containing value.  Note that the last script sent was supposed to return a `Map`, but its `class` is `java.lang.String`.  By default, the connection is configured to only return text results.  In other words, Gremlin Server is using `toString` to serialize all results back to the console.  This enables virtually any object on the server to be returned to the console, but it doesn't allow the opportunity to work with this data in any way in the console itself.  A different configuration of the `:remote` is required to get the results back as "objects":

[source,groovy]
----
gremlin> :remote connect server config/remote-objects.yaml <1>
==>connected - localhost/127.0.0.1:8182
gremlin> :remote list <2>
==>0 - gremlin server - [localhost/127.0.0.1:8182]
==>*1 - gremlin server - [localhost/127.0.0.1:8182]
gremlin> :> g.E.label.groupCount() <3>
==>Item{resultItem={dependsOn=1, created=5, uses=2} class=java.util.HashMap}
gremlin> m = _l[0].get(Map.class) <4>
==>dependsOn=1
==>created=5
==>uses=2
gremlin> m.sort{-it.value}
==>created=5
==>uses=2
==>dependsOn=1
----

<1> This configuration file specifies that results should be deserialized back into an `Object` in the Console with the caveat being that the server and console both know how to serialize and deserialize the result to be returned.
<2> There are now two configured remote connections.  The one marked by an asterisk is the one that was just created and denotes the current one that `:sumbit` will react to.
<3> When the script is executed again, the `class` is no longer shown to be a `java.lang.String`.  It is instead a `java.util.HashMap`.
<4> The last result of a remote script is always stored in the reserved variable `_l`, which allows access to the `Item` and by virtue of that, the `Map` itself.

Connecting via Java
~~~~~~~~~~~~~~~~~~~

[source,xml]
----
<dependency>
   <groupId>com.tinkerpop</groupId>
   <artifactId>gremlin-driver</artifactId>
   <version>3.y.z</version>
</dependency>
----

image:gremlin-java.png[width=175,float=left] TinkerPop3 comes equipped with a reference client for Java-based applications.  It is referred to as Gremlin Driver, which enables applications to send requests to Gremlin Server and get back results.

CAUTION: Gremlin Driver is currently under heavy development.  The API and configuration options are subject to drastic and breaking change.

Gremlin code is sent to the server from a `Client` instance.  A `Client` is created as follows:

[source,java]
----
Cluster cluster = Cluster.open();  <1>
Client client = cluster.connect(); <2>
----

<1> Opens a reference to `localhost` - note that there are many configuration options available in defining a `Cluster` object.
<2> Creates a `Client` given the configuration options of the `Cluster`.

Once a `Client` instance is ready, it is possible to issue some Gremlin:

[source,java]
----
ResultSet results = client.submit("[1,2,3,4]");  <1>
results.stream().map(i -> i.get(Integer.class) * 2);       <2>

CompletableFuture<List<Item>> results = client.submit("[1,2,3,4]").all();  <3>

CompletableFuture<ResultSet> future = client.submitAsync("[1,2,3,4]"); <4>

Map<String,Object> params = new HashMap<>()
params.put("x",4)
client.submit("[1,2,3,x]", params); <5>
----

<1> Submits a script that simply returns a `List` of integers.  This method blocks until the request is written to the server and a `ResultSet` is constructed.
<2> Even though the `ResultSet` is constructed, it does not mean that the server has sent back the results (or even evaluated the script potentially).  The `ResultSet` is just a holder that is awaiting the results from the server.  In this case, they are streamed from the server as they arrive.
<3> Submit a script, get a `ResultSet`, then return a `CompletableFuture` that will be called when all results have been returned.
<4> Submit a script asynchronously without waiting for the request to be written to the server.
<5> Parameterized request are considered the most efficient way to send Gremlin to the server as they can be cached, which will boost performance and reduce resources required on the server.

The above examples submit Gremlin `String` values to the server for evaluation.  It is also possible to submit actual Java-based `Traversal` instances:

[source,java]
----
public static class RemoteTraversal implements SFunction<Graph, Traversal> {
    public Traversal apply(final Graph g) {
        return g.V().out().range(0,9);
    }
}

List<Item> results = client.submit(new RemoteTraversal()).all().get();
----

The code above shows that a `Traversal` instance can be sent for remote execution in Gremlin Server.  This feature is *highly experimental*, but has some interesting implications in that it provides a way to avoid maintaining "fat strings" of Gremlin in the application code base.  While the "fat string" approach can also be avoided by developing a server-side DSL, the sending of an actual `Traversal` provides another method that might provide new and better patterns for developing graph-based applications.

Configuring
~~~~~~~~~~~

As mentioned earlier, Gremlin Server is configured though a YAML file.  By default, Gremlin Server will look for a file called `config/gremlin-server.yaml` to configure itself on startup.  To override this default, supply the file to use to ``bin/gremlin-server.sh` as in:

[source,text]
----
bin/gremlin-server.sh conf/gremlin-server-min.yaml
----

The following table describes the various configuration options that Gremlin Server expects:

[width="100%",cols="3,10,^2",options="header"]
|=========================================================
|Key |Description |Default
|channelizer |Defines the `Channelizer` implementation to use.  A `Channelizer` is a "channel initializer" which Gremlin Server uses to define the type of processing pipeline to use.  By allowing different `Channelizer` implementations, Gremlin Server can support different communication protocols (e.g. Websockets, Java NIO, etc.). |WebSocketChannelizer
|graphs |A `Map` of `Graph` configuration files where the key of the `Map` becomes the name to which the `Graph` will be bound and the value is the file name of a `Graph` configuration file. |_none_
|gremlinPool |The number of "Gremlin" threads available to execute actual scripts in a `ScriptEngine`. This pool represents the workers available to handle blocking operations in Gremlin Server. |8
|host |The name of the host to bind the server to. |localhost
|metrics.consoleReporter.enabled |Turns on console reporting of metrics. |false
|metrics.consoleReporter.interval |Time in milliseconds between reports of metrics to cosole. |180000
|metrics.csvReporter.enabled |Turns on CSV reporting of metrics. |false
|metrics.csvReporter.fileName |The file to write metrics to. |_none_
|metrics.csvReporter.interval |Time in milliseconds between reports of metrics to file. |180000
|metrics.gangliaReporter.addressingMode |Set to `MULTICAST` or `UNICAST`. |_none_
|metrics.gangliaReporter.enabled |Turns on Ganglia reporting of metrics. |false
|metrics.gangliaReporter.host |Define the Ganglia host to report Metrics to. |localhost
|metrics.gangliaReporter.interval |Time in milliseconds between reports of metrics for Ganglia. |180000
|metrics.gangliaReporter.port |Define the Ganglia port to report Metrics to. |8649
|metrics.graphiteReporter.enabled |Turns on Graphite reporting of metrics. |false
|metrics.graphiteReporter.host |Define the Graphite host to report Metrics to. |localhost
|metrics.graphiteReporter.interval |Time in milliseconds between reports of metrics for Graphite. |180000
|metrics.graphiteReporter.port |Define the Graphite port to report Metrics to. |2003
|metrics.graphiteReporter.prefix |Define a "prefix" to append to metrics keys reported to Graphite. |_none_
|metrics.jmxReporter.enabled |Turns on JMX reporting of metrics. |false
|metrics.slf4jReporter.enabled |Turns on SLF4j reporting of metrics. |false
|metrics.slf4jReporter.interval |Time in milliseconds between reports of metrics to SLF4j. |180000
|port |The port to bind the server to. |8182
|processors |A `List` of `Map` settings, where each `Map` represents a `OpProcessor` implementation to use along with its configuration. |_none_
|processors[X].className |The full class name of the `OpProcessor` implementation. |_none_
|processors[X].config |A `Map` containing `OpProcessor` specific configurations. |_none_
|resultIterationBatchSize |Defines the size in which the result of a request is "batched" back to the client.  In other words, if set to `1`, then a result that had ten items in it would get each result sent back individually.  If set to `2` the same ten results would come back in five batches of two each. |64
|scriptEngines |A `Map` of `ScriptEngine` implementations to expose through Gremlin Server, where the key is the name given by the `ScriptEngine` implementation.  The key must match the name exactly for the `ScriptEngine` to be constructed.  The value paired with this key is itself a `Map` of configuration for that `ScriptEngine`.  |_none_
|scriptEngines.<name>.imports |A comma separated list of classes/packages to make available to the `ScriptEngine`. |_none_
|scriptEngines.<name>.staticImports |A comma separated list of "static" imports to make available to the `ScriptEngine`. |_none_
|scriptEngines.<name>.scripts |A comma separated list of script files to execute on `ScriptEngine` initialization. |_none_
|scriptEngines.<name>.config |A `Map` of configuration settings for the `ScriptEngine`.  These settings are dependent on the `ScriptEngine` implementation being used. |_none_
|scriptEvaluationTimeout |The amount of time in milliseconds before a script evaluation times out. The notion of "script evaluation" refers to the time it takes for the `ScriptEngine` to do its work and *not* any additional time it takes for the result of the evaluation to be iterated and serialized. |30000
|serializers |A `List` of `Map` settings, where each `Map` represents a `MessageSerializer` implementation to use along with its configuration. |_none_
|serializers[X].className |The full class name of the `MessageSerializer` implementation. |_none_
|serializers[X].config |A `Map` containing `MessageSerializer` specific configurations. |_none_
|serializedResponseTimeout |The amount of time in milliseconds before a response serialization times out.  The notion of "response serialization" refers to the time it takes for Gremlin Server to iterate an entire result after the script is evaluated in the `ScriptEngine`. |30000
|ssl.enabled |Determines if SSL is turned on or not. |false
|threadPoolBoss |The number of threads available to Gremlin Server for accepting connections. Should always be set to `1`. |1
|threadPoolWorker |The number of threads available to Gremlin Server for processing non-blocking reads and writes. |1
|use |A list of Maven coordinates that represent external libraries to be made available to the `ScriptEngine`.  Alternatively, dependencies may be copied directly to the Gremlin Server path. |_none_
|=========================================================

Tuning
~~~~~~

image:gremlin-handdrawn.png[width=120,float=right] Tuning Gremlin Server for a particular environment may require some simple trial-and-error, but the following represent some basic guidelines that might be useful:

* A "good" setting for `threadPoolWorker` is `2*number of cores`.  If a smaller setting can be used there while still achieving performance needs, then choose the smaller setting.  If a larger setting is needed, then consider a server with more cores.
* The "right" size of the `gremlinPool` setting is somewhat dependent on the type of scripts that will be processed by Gremlin Server.  As requests arrive to Gremlin Server they are decoded and queued to be processed by threads in this pool.  When this pool is exhausted of threads, Gremlin Server will continue to accept incoming requests, but the queue will continue to grow.  If left to grow too large, the server will begin to slow.  When tuning around this setting, consider whether the bulk of the scripts being processed will be "fast" or "slow", where "fast" generally means being measured in the low hundreds of milliseconds and "slow" means anything longer than that.
** If the bulk of the scripts being processed are expected to be "fast", then a good starting point for this setting is `2*threadPoolWorker`.
** If the bulk of the scripts being processed are expected to be "slow", then a good starting point for this setting is `4*threadPoolWorker`.
* Scripts that are "slow" can really hurt Gremlin Server if they are not properly accounted for.  `ScriptEngine` evaluations are blocking operations that aren't easily interrupted, so once a "slow" script is being evaluated in the context of a `ScriptEngine` it must finish its work.  Lots of "slow" scripts will eventually consume the `gremlinPool` preventing other scripts from getting processed from the queue.
** To limit the impact of this problem consider properly setting the `scriptEvaluationTimeout` and the `serializedResponseTimeout` to something "sane".
** Test the traversals being sent to Gremlin Server and determine the maximum time they take to evaluate and iterate over results, then set these configurations accordingly.
** Note that `scriptEvaluationTimeout` does not interrupt the evaluation on timeout.  It merely allows Gremlin Server to "ignore" the result of that evaluation, which means the thread in the `gremlinPool` will still be consumed after the timeout.
** The more powerful setting is the `serializedResponseTimeout`, which will actually kill the result iteration process and prevent additional processing.  In most situations, the iteration and serialization process is the more costly step in this process as an errant script that retuns a million or more results could send Gremlin Server into a long streaming cycle.  Script evaluation on the other hand is usually very fast, occurring on the order of milliseconds, but that is entirely dependent on the contents of the script itself.

Implementations
===============

image::gremlin-racecar.png[width=325]

[[vendor-requirements]]
Vendor Requirements
-------------------

image:tinkerpop-enabled.png[width=125,float=left] At the core of TinkerPop3 is a Java8 API. The implementation of this core API and its validation via the `gremlin-test` suite is all that is required of a vendor wishing to provide a TinkerPop3-enabled graph engine. Once a vendor has a valid implementation, then all the applications provided by TinkerPop (e.g. Gremlin Console, Gremlin Server, etc.) and 3rd-party developers (e.g. Gremlin-Scale, Gremlin-JS, etc.) will integrate properly with their graph engine. Finally, please feel free to use the logo on the left to promote your TinkerPop3 implementation.

Implementing Gremlin-Core
~~~~~~~~~~~~~~~~~~~~~~~~~

The classes that a vendor should focus on implemented are itemized below. Please feel free to study the TinkerGraph (in-memory OLTP and OLAP in `tinkergraph-gremlin`), Neo4jGraph (OTLP w/ transactions in `neo4j-gremlin`) and/or GiraphGraph (OLAP in `giraph-gremlin`) implementations for ideas and patterns.

. Online Transactional Processing Graph Systems (*OLTP*)
 .. Structure API: `Graph`, `Element`, `Vertex`, `Edge`, `Property` and `Transaction` (if transactions are supported).
 .. Process API: a single `Step` that states how to yield vertices or edges from a `Graph` (i.e. `Graph.V()` and `Graph.E()`).
. Online Analytics Processing Graph Systems (*OLAP*)
 .. Everything required of OTLP is required of OLAP (but not vice versa).
 .. GraphComputer API: `GraphComputer`, `Messenger`, `SideEffects`.

A collection of implementation notes:

* Please ensure your `Graph` implementation is named as `XXXGraph` (e.g. TinkerGraph, Neo4jGraph, GiraphGraph, etc.).
* Use `StringHelper` to ensuring that the `toString()` representation of classes are consistent with other implementations.
* Ensure that your implementation's `Features` (Graph, Vertex, etc.) are correct so that test cases handle particulars accordingly.

Validating with Gremlin-Test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[source,xml]
<dependency>
  <groupId>com.tinkerpop</groupId>
  <artifactId>gremlin-test</artifactId>
  <version>3.y.z</version>
</dependency>

The operational semantics of any OLTP or OLAP implementation are validated by `gremlin-test`. Please provide the following test cases with your implementation, where `XXX` below denotes the name of your graph implementation (e.g. TinkerGraph, Neo4jGraph, GiraphGraph, etc.).

[source,java]
----
// Structure API tests
@RunWith(StructureStandardSuite.class)
@StructureStandardSuite.GraphProviderClass(XXXGraphProvider.class)
public class XXXStructureStandardTest {}

@RunWith(StructurePerformanceSuite.class)
@StructurePerformanceSuite.GraphProviderClass(XXXGraphProvider.class)
public class XXXStructurePerformanceTest {}

// Process API tests
@RunWith(ProcessComputerSuite.class)
@ProcessComputerSuite.GraphProviderClass(XXXGraphProvider.class)
public class XXXProcessComputerTest {}

@RunWith(ProcessStandardSuite.class)
@ProcessStandardSuite.GraphProviderClass(XXXGraphProvider.class)
public class XXXProcessStandardTest {}
----

The only test-class that requires any code investment is the `XXXGraphProvider.class`. Neo4j's implementation is provided below for reference.

[source,java]
----
public class Neo4jGraphProvider extends AbstractGraphProvider {
    @Override
    public Map<String, Object> getBaseConfiguration(final String graphName) {
	// this is what is passed into XXX.open()
        return new HashMap<String, Object>() {{
            put("gremlin.graph", Neo4jGraph.class.getName());
            put("gremlin.neo4j.directory", getWorkingDirectory() + File.separator + graphName);
        }};
    }

    @Override
    public void clear(final Graph g, final Configuration configuration) throws Exception {
        if (null != g) {
            if (g.getFeatures().graph().supportsTransactions())
                g.tx().rollback();
            g.close();
        }
        if (configuration.containsKey("gremlin.neo4j.directory")) {
            // this is a non-in-memory configuration so blow away the directory
            final File graphDirectory = new File(configuration.getString("gremlin.neo4j.directory"));
            deleteDirectory(graphDirectory);
        }
    }
}
---- 

Accessibility via GremlinPlugin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

image:gremlin-plugin.png[width=100,float=left] The applications distributed with TinkerPop3 do not distribute with any vendor implementations besides TinkerGraph. If your implementation is stored in a Maven repository (e.g. Maven Central Repository), then it is best to provide a `GremlinPlugin` implementation so the respective jars can be downloaded according and when required by the user. Neo4j's GremlinPlugin is provided below for reference.

[source,java]
----
public class Neo4jGremlinPlugin implements GremlinPlugin {

    private static final String IMPORT = "import ";
    private static final String DOT_STAR = ".*";

    private static final Set<String> IMPORTS = new HashSet<String>() {{
        add(IMPORT + Neo4jGraph.class.getPackage().getName() + DOT_STAR);
    }};

    @Override
    public String getName() {
        return "neo4j";
    }

    @Override
    public void pluginTo(final PluginAcceptor pluginAcceptor) {
        pluginAcceptor.addImports(IMPORTS);
    }
}
---- 

With the above plugin implementations, users can now download respective binaries for Gremlin Console, Gremlin Server, etc.

[source,groovy]
gremlin> g = Neo4jGraph.open('/tmp/neo4j')
No such property: Neo4jGraph for class: groovysh_evaluate
Display stack trace? [yN]
gremlin> :use now com.tinkerpop neo4j-gremlin 3.0.0
…
gremlin> g = Neo4jGraph.open('/tmp/neo4j')
==>neo4jgraph[EmbeddedGraphDatabase [/tmp/neo4j]]

In-Depth Implementations
~~~~~~~~~~~~~~~~~~~~~~~~

image:gremlin-handdrawn.png[width=125,float=right] The vendor implementation details presented thus far are minimum requirements necessary to yield a valid TinkerPop3 implementation. However, there are other areas that a vendor can tweak to provide an implementation more optimized for their underlying graph engine. Typical areas of focus include:

* Traversal Strategies: A <<traversalstrategy,TraversalStrategy>> can be used to alter a traversal prior to its execution. A typical example is converting a pattern of `g.V().has('name','marko')` into a global index lookup for all vertices with name "marko". In this way, a `O(|V|)` lookup becomes an `O(log(|V|))` Please review `TinkerGraphStepStrategy` for ideas.
* Step Implementations: Every <<graph-traversal-steps,step>> if reference via the `GraphTraversal` interface. It is possible to extend `GraphTraversal` to use a vendor-specific step implementation.


[[tinkergraph-gremlin]]
TinkerGraph-Gremlin
-------------------

[source,xml]
----
<dependency>
   <groupId>com.tinkerpop</groupId>
   <artifactId>tinkergraph-gremlin</artifactId>
   <version>3.y.z</version>
</dependency>
----

image:tinkerpop-character.png[width=100,float=left] TinkerGraph is a single machine, in-memory, non-transactional graph engine that provides both OLTP and OLAP functionality. It is deployed with TinkerPop3 and serves as the reference implementation for other vendors to study in order to understand the semantics of the various methods of the TinkerPop3 API. Constructing a simple graph in Java8 is presented below.

[source,java]
Graph g = TinkerGraph.open();
Vertex marko = g.addVertex("name","marko","age",29);
Vertex lop = g.addVertex("name","lop","lang","java");
marko.addEdge("created",lop,"weight",0.6d);

The above graph creates two vertices named "marko" and "lop" and connects them via a created-edge with a weight=0.6 property. Next, the graph can be queried as such.

[source,java]
g.V().has("name","marko").out("created").value("name")

The `g.V().has("name","marko")` part of the query can be executed in two ways.

 * A linear scan of all vertices filtering out those vertices that don't have the name "marko"
 * A `O(log(|V|))` index lookup for all vertices with the name "marko"

Given the initial graph construction in the first code block, no index was defined and thus, a linear scan is executed. However, if the graph was constructed as such, then an index lookup would be used.

[source,java]
Graph g = TinkerGraph.open();
g.createIndex("name",Vertex.class)

Each graph vendor will have different mechanism by which indices and schemas are defined. TinkerPop3 does not require any conformance in this area. In TinkerGraph, the only definitions are around indices. With other vendors, property value types, indices, edge labels, etc. may be required to be defined _a priori_ to adding data to the graph.

[[neo4j-gremlin]]
Neo4j-Gremlin
-------------

[source,xml]
----
<dependency>
   <groupId>com.tinkerpop</groupId>
   <artifactId>neo4j-gremlin</artifactId>
   <version>3.y.z</version>
</dependency>
----

image:neotechnology-logo.png[width=150,float=left] link:http://neotechnology.com[Neo Technology] are the developers of the OLTP-based link:http://neo4j.org[Neo4j graph database].

CAUTION: Unless under a commercial agreement with Neo Technology, Neo4j is licensed as link:http://en.wikipedia.org/wiki/Affero_General_Public_License[AGPL]. Thus, `gremlin-neo4j` (source and binaries) are licensed as such due to their dependency on the Neo4j library. Note that neither the <<gremlin-console,Gremlin Console>> nor <<gremlin-server,Gremlin Server>> distribute with the Neo4j binaries. To access the Neo4j binaries, use the `:use` command to download binaries from link:http://search.maven.org/[Maven Central Repository].

[source,groovy]
----
gremlin> :use now com.tinkerpop neo4j-gremlin x.y.z
==>groovy.grape.Grape, org.apache.commons.configuration.*, com.tinkerpop.gremlin.structure.*, ... com.tinkerpop.gremlin.neo4j.structure.*
==>loaded: {disableChecksums=false, module=neo4j-gremlin, autoDownload=true, calleeDepth=4, changing=false, version=3.0.0-SNAPSHOT, group=com.tinkerpop.tinkerpop3}
gremlin> g = Neo4jGraph.open('/tmp/neo4j')
==>neo4jgraph[EmbeddedGraphDatabase [/tmp/neo4j]]
----

For those leveraging Neo4j High Availability, configure `Neo4jGraph` for "HA mode" by setting the `gremlin.neo4j.ha` flag to `true` in the `Configuration` object passed to `Neo4jGraph.open()`.  Note that when the flag is set (by default it is `false`), the `Neo4jGraph` instance expects HA configuration settings to be present.  As with embedded Neo4j, HA configuration keys should be prefixed with `gremlin.neo4j.conf`.  Please consult Neo4j documentation for more information on link:http://docs.neo4j.org/chunked/stable/ha.html[High Availability] configuration.

Cypher
~~~~~~

Neo4j are the creators of the graph pattern-match query language link:http://www.neo4j.org/learn/cypher[Cypher]. It is possible to leverage Cypher from within Gremlin by using the `Neo4jGraph.cypher()` graph traversal method.

[source,groovy]
gremlin> g = Neo4jGraph.open('/tmp/neo4j')
==>neo4jgraph[EmbeddedGraphDatabase [/tmp/neo4j]]
gremlin> g.loadKryo('data/tinkerpop-classic.gio')
==>null
gremlin> g.cypher('MATCH (a {name:"marko"}) RETURN a')
==>[a:v[0]]
gremlin> g.cypher('MATCH (a {name:"marko"}) RETURN a').select('a').out('knows').name
==>vadas
==>josh

Thus, like <<match-step,`match()`>> in Gremlin, it is possible to do a declarative pattern match and then move back into imperative Gremlin.

IMPORTANT: For those developers using <<gremlin-server,Gremlin Server>> against Neo4j, it is possible to do Cypher queries by simply placing the Cypher string in `g.cypher(...)` before submission to the server.


[[giraph-gremlin]]
Giraph-Gremlin
--------------

[source,xml]
----
<dependency>
   <groupId>com.tinkerpop</groupId>
   <artifactId>giraph-gremlin</artifactId>
   <version>3.y.z</version>
</dependency>
----

image:giraph-logo.png[width=100,float=left] link:http://giraph.apache.org[Giraph] is an Apache Foundation project focused on OLAP-based graph processing. Giraph makes use of the distributed graph computing paradigm made popular by Google's Pregel. In Giraph, developers write "vertex programs" that get executed at each vertex in parallel. These programs communicate with one another in a bulk synchronous parallel (BSP) manner. This model aligns with TinkerPop3's `GraphComputer` API. TinkerPop3 provides an implementation of `GraphComputer` that works for Giraph called `GiraphGraphComputer`. Moreover, with TinkerPop3's <<mapreduce,MapReduce>>-framework, the standard Giraph/Pregel model is extended to support an arbitrary number of MapReduce phases to aggregate and yield results from the graph. Finally, note that `GiraphGraph` also supports read-only OLTP operations (though via linear scans of HDFS serializations).

IMPORTANT: image:hadoop-logo-notext.png[width=100,float=left] This section assumes that the user has a Hadoop 1.x cluster functioning. For more information on getting started with Hadoop, please see their link:http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html[Single Node Setup] tutorial. Moreover, it is advisable that the reader also familiarize themselves with Giraph as well via their link:http://giraph.apache.org/quick_start.html[Getting Started] page.

Installing Giraph-Gremlin
~~~~~~~~~~~~~~~~~~~~~~~~~

To the `.bash_profile` file, add the following environmental variables (of course, be sure the directories are respective of the local machine locations).

[source,shell]
export GIRAPH_HOME=/usr/local/giraph-1.0.0
export GIRAPH_GREMLIN_HOME=/usr/local/giraph-gremlin-3.0.0

If using the <<gremlin-console,Gremlin Console>>, it is important to install the Giraph-Gremlin plugin.

[source,text]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin loaded: server
plugin loaded: gephi
plugin loaded: utilities
gremlin> :use install com.tinkerpop giraph-gremlin 3.0.0
==>loaded: [com.tinkerpop, giraph-gremlin, 3.0.0] - restart the console to use [giraph]
gremlin> :q
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin loaded: server
plugin loaded: gephi
plugin loaded: utilities
plugin loaded: giraph
gremlin>
----

Properties Files
~~~~~~~~~~~~~~~~

The `GiraphGraphComputer` makes use of a properties file much like any other `GraphComputer`. However, given the relationship to Hadoop which is property heavy, it is important to look at a particular properties file. The properties file below is located at `conf/giraph-kryo.properties'.

[source,text]
gremlin.inputLocation=tinkerpop-classic-vertices.gio
giraph.vertexInputFormatClass=com.tinkerpop.gremlin.giraph.structure.io.kryo.KryoVertexInputFormat
gremlin.outputLocation=output
giraph.vertexOutputFormatClass=com.tinkerpop.gremlin.giraph.structure.io.kryo.KryoVertexOutputFormat
gremlin.sideEffectOutputFormatClass=org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat
gremlin.vertexProgram=com.tinkerpop.gremlin.process.computer.traversal.TraversalVertexProgram
gremlin.traversalVertexProgram.traversalSupplierClass=com.tinkerpop.gremlin.giraph.process.graph.example.TraversalSupplier1
gremlin.jarsInDistributedCache=true
gremlin.deriveComputerSideEffects=false
giraph.minWorkers=2
giraph.maxWorkers=2

A review of the properties above are presented in the table below.

[width="100%",cols="2,10",options="header"]
|=========================================================
|Property |Description
|gremlin.inputLocation |The location of the input file(s) for Giraph to read the graph from.
|giraph.vertexInputFormatClass |The format that the graph input file(s) are represented in.
|gremlin.outputLocation |The location to write the computed Giraph graph to.
|giraph.vertexOutputFormatClass |The format that the output file(s) should be represented in.
|gremlin.sideEffectOutputFormatClass |The format of any resultant GraphComputer SideEffects.
|gremlin.vertexProgram |The `VertexProgram` to distribute to all vertices in the `GiraphGraph`
|gremlin.traversalVertexProgram.traversalSupplierClass |For `TraversalVertexProgram`, the location of the Gremlin traversal to use (if not using Gremlin Console).
|gremlin.jarsInDistributedCache |Whether to upload the Giraph-Gremlin jars to Hadoop's distributed cache (necessary if jars are not on machines' classpaths).
|gremlin.deriveComputerSideEffects |Whether or not `SideEffects` are yielded (requires an extra MapReduce job if true).
|giraph.minWorkers |The minimum number of parallel workers to execute the vertices of the graph.
|giraph.maxWorkers |The maximum number of parallel workers to execute the vertices of the graph.
|=========================================================

IMPORTANT: The maximum number of workers can be no larger than the number of map-slots in the Hadoop cluster minus 1. For example, if the Hadoop cluster has 4 map slots, then `giraph.maxWorkers` can not be larger than 3. One map-slot is reserved for the master compute node and all other slots can be allocated as workers to execute the VertexPrograms on the vertices of the graph.

The above properties file states:

	The location of the graph is tinkerpop-classic-vertices.gio. Interpret that file using KryoVertexInputFormat. When evaluating the graph over the Giraph/Hadoop cluster, execute the TraversalVertexProgram on all vertices of the graph using the traversal defined in TraversalSupplier1. Write the computed on GiraphGraph to output/ using the KryoVertexOutputFormat. Use 2 workers (thus, 3 map-slots) to execute the job.
 
Along with the properties above, the numerous link:http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/core-default.xml[Hadoop specific properties] can be added as needed to tune and parameterize the executed Giraph-Gremlin job on the respective Hadoop cluster.

OLTP Giraph-Gremlin
~~~~~~~~~~~~~~~~~~~

image:giraph-pipes.png[width=110,float=left] It is possible to execute OLTP operations over Giraph-Gremlin. However, realize that the underlying HDFS files are typically not random access and thus, to retrieve a vertex, a linear scan is required. It is possible to create input formats that leverage Hadoop Map files.

CAUTION: OLTP operations on `GiraphGraph` are not efficient. They require linear scans to execute and are unreasonable for large graphs. In such large graph situations, make use of <<traversalvertexprogram,TraversalVertexProgram>> which is the OLAP implementation of the Gremlin language.

[source,text]
gremlin> hdfs.copyFromLocal('../../../data/tinkerpop-classic-vertices.gio', 'tinkerpop-classic-vertices.gio')
==>null
gremlin> hdfs.ls()
==>rw-r--r-- marko supergroup 891 tinkerpop-classic-vertices.gio
gremlin> conf = new PropertiesConfiguration()
==>org.apache.commons.configuration.PropertiesConfiguration@37d3d232
gremlin> conf.load('../../../giraph-gremlin/conf/giraph-kryo.properties')
==>null
gremlin> g = GiraphGraph.open(conf)
==>giraphgraph[kryovertexinputformat->kryovertexoutputformat]
gremlin> g.V.count()
==>6
gremlin> g.V.out.out.name
==>ripple
==>lop
gremlin> g.V.groupBy{it.value('name')[1]}{it.value('name')}.next()
==>a=[marko, vadas]
==>e=[peter]
==>i=[ripple]
==>o=[lop, josh]

OLAP Giraph-Gremlin
~~~~~~~~~~~~~~~~~~~

image:giraph-furnace.png[width=110,float=left] Giraph-Gremlin was designed to execute OLAP operations via `GraphComputer`. The OLTP examples presented above are reproduced below, but using `TraversalVertexProgram` for the execution of the Gremlin traversal.

IMPORTANT: When using Giraph-Gremlin OLAP from the Gremlin Console, the only Gremlin language subset supported is Gremlin-Groovy.

[source,text]
gremlin> :remote connect giraph ../../../giraph-gremlin/conf/giraph-kryo.properties
==>giraphgraph[kryovertexinputformat->kryovertexoutputformat]
gremlin> :> g.V.count()
INFO  com.tinkerpop.gremlin.giraph.process.computer.GiraphGraphComputer  - GiraphGremlin: TraversalVertexProgram[GiraphGraphStep, CountStep]
INFO  org.apache.hadoop.mapred.JobClient  - Running job: job_201407281259_0037
INFO  org.apache.hadoop.mapred.JobClient  -  map 0% reduce 0%
...
INFO  com.tinkerpop.gremlin.giraph.process.computer.GiraphGraphComputer  - GiraphGremlin: CountCapMapReduce
INFO  org.apache.hadoop.mapred.JobClient  - Running job: job_201407281259_0038
INFO  org.apache.hadoop.mapred.JobClient  -  map 0% reduce 0%
...
==>6
gremlin> :> g.V.out.out.name
INFO  com.tinkerpop.gremlin.giraph.process.computer.GiraphGraphComputer  - GiraphGremlin: TraversalVertexProgram[GiraphGraphStep, VertexStep(OUT), VertexStep(OUT), ElementValueStep(name)]
INFO  org.apache.hadoop.mapred.JobClient  - Running job: job_201407281259_0031
INFO  org.apache.hadoop.mapred.JobClient  -  map 0% reduce 0%
...
INFO  com.tinkerpop.gremlin.giraph.process.computer.GiraphGraphComputer  - GiraphGremlin: TraversalResultMapReduce
INFO  org.apache.hadoop.mapred.JobClient  - Running job: job_201407281259_0032
INFO  org.apache.hadoop.mapred.JobClient  -  map 0% reduce 0%
...
==>ripple
==>lop
gremlin> :> g.V.groupBy{it.value('name')[1]}{it.value('name')}
INFO  com.tinkerpop.gremlin.giraph.process.computer.GiraphGraphComputer  - GiraphGremlin: TraversalVertexProgram[GiraphGraphStep, GroupByStep]
INFO  org.apache.hadoop.mapred.JobClient  - Running job: job_201407281259_0039
INFO  org.apache.hadoop.mapred.JobClient  -  map 0% reduce 0%
...
INFO  com.tinkerpop.gremlin.giraph.process.computer.GiraphGraphComputer  - GiraphGremlin: GroupByMapReduce
INFO  org.apache.hadoop.mapred.JobClient  - Running job: job_201407281259_0040
INFO  org.apache.hadoop.mapred.JobClient  -  map 0% reduce 0%
...
==>[a:[marko, vadas], e:[peter], i:[ripple], o:[lop, josh]]
gremlin> _l.next()
==>a=[marko, vadas]
==>e=[peter]
==>i=[ripple]
==>o=[lop, josh]

The results of the graph traversal are stored in HDFS accessible via `hdfs`.

[source,text]
gremlin> hdfs.ls()
==>rwxr-xr-x marko supergroup 0 (D) output
==>rw-r--r-- marko supergroup 891 tinkerpop-classic-vertices.gio
gremlin> hdfs.ls('output')
==>rwxr-xr-x marko supergroup 0 (D) ~cap
==>rwxr-xr-x marko supergroup 0 (D) ~g
gremlin> hdfs.ls('output/~cap')
==>rw-r--r-- marko supergroup 0 _SUCCESS
==>rwxr-xr-x marko supergroup 0 (D) _logs
==>rw-r--r-- marko supergroup 332 part-r-00000
gremlin> hdfs.head('output/~cap',KryoWritable.class)
==>[a, [marko, vadas]]
==>[e, [peter]]
==>[i, [ripple]]
==>[o, [lop, josh]]

A list of the HDFS methods available are itemized below. Note that these methods are also available for the 'local' variable:

[width="100%",cols="13,10",options="header"]
|=========================================================
| Method| Description
|hdfs.ls(String path)| List the contents of the supplied directory. 
|hdfs.cp(String from, String to)| Copy the specified path to the specified path.
|hdfs.exists(String path)| Whether the specified path exists.
|hdfs.rm(String path)| Remove the specified path.
|hdfs.rmr(String path)| Remove the specified path and its contents recurssively.
|hdfs.copyToLocal(String from, String to)| Copy the specified HDFS path to the specified local path.
|hdfs.copyFromLocal(String from, String to)| Copy the specified local path to the specified HDFS path.
|hdfs.mergeToLocal(String from, String to)| Merge the files in path to the specified local path.
|hdfs.head(String path)| Text display the data in the path.
|hdfs.head(String path, long lineCount)| Text display only the first `totalKeyValues` in the path.
|hdfs.head(String path, long totalKeyValues, Class<Writable> writableClass)| Display the path interpreting the key values as respective writable.
|=========================================================


The `TraversalSupplier1` class mentioned in the `giraph-kryo.properties` file is distributed with Giraph-Gremlin. It declares what Gremlin-Java traversal to execute on the loaded `GiraphGraph`. This is the means why which traversals can be programmatically executed in Giraph-Gremlin.

[source,java]
----
// gremlin.traversalVertexProgram.traversalSupplierClass=com.tinkerpop.gremlin.giraph.process.graph.example.TraversalSupplier1

public class TraversalSupplier1 implements SSupplier<Traversal> {
    public Traversal get() {
        return GiraphGraph.open().V().out().out().value("name");
    }
}
----

A Command Line Example
~~~~~~~~~~~~~~~~~~~~~~

image::pagerank-logo.png[width=300]

The classic link:http://en.wikipedia.org/wiki/PageRank[PageRank] centrality algorithm can be executed over TinkerPop classic from the command line.

NOTE: The extension `ldjson` in `giraph-graphson.properties` refers to link:http://en.wikipedia.org/wiki/Line_Delimited_JSON[line-delimitated JSON] which is the file format used by `GraphSONWriter` when writing an link:http://en.wikipedia.org/wiki/Adjacency_list[adjacency list] representation of a graph.

[source,text]
$ hadoop fs -copyFromLocal ../data/tinkergraph-classic-vertices.ldjson tinkergraph-classic-vertices.ldjson
$ hadoop fs -ls
Found 2 items
-rw-r--r--   1 marko supergroup        891 2014-07-28 13:00 /user/marko/tinkerpop-classic-vertices.gio
-rw-r--r--   1 marko supergroup       2356 2014-07-28 13:00 /user/marko/tinkerpop-classic-vertices.ldjson
$ hadoop jar target/giraph-gremlin-3.0.0-job.jar com.tinkerpop.gremlin.giraph.process.computer.GiraphGraphComputer conf/giraph-graphson.properties
14/07/29 12:08:27 INFO computer.GiraphGraphComputer: GiraphGremlin: com.tinkerpop.gremlin.process.computer.ranking.pagerank.PageRankVertexProgram
14/07/29 12:08:28 INFO mapred.JobClient: Running job: job_201407281259_0041
14/07/29 12:08:29 INFO mapred.JobClient:  map 0% reduce 0%
14/07/29 12:08:51 INFO mapred.JobClient:  map 66% reduce 0%
14/07/29 12:08:52 INFO mapred.JobClient:  map 100% reduce 0%
14/07/29 12:08:54 INFO mapred.JobClient: Job complete: job_201407281259_0041
14/07/29 12:08:54 INFO mapred.JobClient: Counters: 57
14/07/29 12:08:54 INFO mapred.JobClient:   Map-Reduce Framework
14/07/29 12:08:54 INFO mapred.JobClient:     Spilled Records=0
14/07/29 12:08:54 INFO mapred.JobClient:     Map input records=3
14/07/29 12:08:54 INFO mapred.JobClient:     SPLIT_RAW_BYTES=132
14/07/29 12:08:54 INFO mapred.JobClient:     Map output records=0
14/07/29 12:08:54 INFO mapred.JobClient:     Total committed heap usage (bytes)=347602944
14/07/29 12:08:54 INFO mapred.JobClient:   Giraph Timers
14/07/29 12:08:54 INFO mapred.JobClient:     Shutdown (milliseconds)=385
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 1 (milliseconds)=89
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 23 (milliseconds)=28
14/07/29 12:08:54 INFO mapred.JobClient:     Input superstep (milliseconds)=1127
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 27 (milliseconds)=30
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 10 (milliseconds)=34
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 5 (milliseconds)=43
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 22 (milliseconds)=31
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 14 (milliseconds)=35
14/07/29 12:08:54 INFO mapred.JobClient:     Total (milliseconds)=4023
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 2 (milliseconds)=50
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 18 (milliseconds)=29
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 11 (milliseconds)=35
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 24 (milliseconds)=32
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 28 (milliseconds)=32
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 15 (milliseconds)=34
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 6 (milliseconds)=37
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 19 (milliseconds)=31
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 25 (milliseconds)=27
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 8 (milliseconds)=33
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 12 (milliseconds)=44
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 20 (milliseconds)=31
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 16 (milliseconds)=31
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 9 (milliseconds)=36
14/07/29 12:08:54 INFO mapred.JobClient:     Setup (milliseconds)=1119
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 3 (milliseconds)=50
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 7 (milliseconds)=38
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 13 (milliseconds)=36
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 29 (milliseconds)=37
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 26 (milliseconds)=40
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 0 (milliseconds)=293
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 21 (milliseconds)=46
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 17 (milliseconds)=32
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep 4 (milliseconds)=39
14/07/29 12:08:54 INFO mapred.JobClient:   File Input Format Counters
14/07/29 12:08:54 INFO mapred.JobClient:     Bytes Read=0
14/07/29 12:08:54 INFO mapred.JobClient:   Giraph Stats
14/07/29 12:08:54 INFO mapred.JobClient:     Aggregate finished vertices=0
14/07/29 12:08:54 INFO mapred.JobClient:     Aggregate edges=0
14/07/29 12:08:54 INFO mapred.JobClient:     Sent messages=6
14/07/29 12:08:54 INFO mapred.JobClient:     Current workers=2
14/07/29 12:08:54 INFO mapred.JobClient:     Last checkpointed superstep=0
14/07/29 12:08:54 INFO mapred.JobClient:     Current master task partition=0
14/07/29 12:08:54 INFO mapred.JobClient:     Superstep=30
14/07/29 12:08:54 INFO mapred.JobClient:     Aggregate vertices=6
14/07/29 12:08:54 INFO mapred.JobClient:   FileSystemCounters
14/07/29 12:08:54 INFO mapred.JobClient:     HDFS_BYTES_READ=2488
14/07/29 12:08:54 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=250470
14/07/29 12:08:54 INFO mapred.JobClient:     HDFS_BYTES_WRITTEN=2719
14/07/29 12:08:54 INFO mapred.JobClient:   Job Counters
14/07/29 12:08:54 INFO mapred.JobClient:     Launched map tasks=3
14/07/29 12:08:54 INFO mapred.JobClient:     SLOTS_MILLIS_REDUCES=0
14/07/29 12:08:54 INFO mapred.JobClient:     Total time spent by all reduces waiting after reserving slots (ms)=0
14/07/29 12:08:54 INFO mapred.JobClient:     SLOTS_MILLIS_MAPS=31907
14/07/29 12:08:54 INFO mapred.JobClient:     Total time spent by all maps waiting after reserving slots (ms)=0
14/07/29 12:08:54 INFO mapred.JobClient:   File Output Format Counters
14/07/29 12:08:54 INFO mapred.JobClient:     Bytes Written=0
$ hadoop fs -cat output/~g/*
{"inE":[],"outE":[{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":9,"label":"created","type":"edge","outV":1,"hiddens":{},"properties":{"weight":0.4}},{"inV":2,"inVLabel":"vertex","outVLabel":"vertex","id":7,"label":"knows","type":"edge","outV":1,"hiddens":{},"properties":{"weight":0.5}},{"inV":4,"inVLabel":"vertex","outVLabel":"vertex","id":8,"label":"knows","type":"edge","outV":1,"hiddens":{},"properties":{"weight":1.0}}],"id":1,"label":"vertex","type":"vertex","hiddens":{"gremlin.pageRank":0.15000000000000002,"gremlin.edgeCount":3.0},"properties":{"name":"marko","age":29}}
{"inE":[{"inV":5,"inVLabel":"vertex","outVLabel":"vertex","id":10,"label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":1.0}}],"outE":[],"id":5,"label":"vertex","type":"vertex","hiddens":{"gremlin.pageRank":0.23181250000000003,"gremlin.edgeCount":0.0},"properties":{"name":"ripple","lang":"java"}}
{"inE":[{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":9,"label":"created","type":"edge","outV":1,"hiddens":{},"properties":{"weight":0.4}},{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":11,"label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":0.4}},{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":12,"label":"created","type":"edge","outV":6,"hiddens":{},"properties":{"weight":0.2}}],"outE":[],"id":3,"label":"vertex","type":"vertex","hiddens":{"gremlin.pageRank":0.4018125,"gremlin.edgeCount":0.0},"properties":{"name":"lop","lang":"java"}}
{"inE":[{"inV":4,"inVLabel":"vertex","outVLabel":"vertex","id":8,"label":"knows","type":"edge","outV":1,"hiddens":{},"properties":{"weight":1.0}}],"outE":[{"inV":5,"inVLabel":"vertex","outVLabel":"vertex","id":10,"label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":1.0}},{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":11,"label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":0.4}}],"id":4,"label":"vertex","type":"vertex","hiddens":{"gremlin.pageRank":0.19250000000000003,"gremlin.edgeCount":2.0},"properties":{"name":"josh","age":32}}
{"inE":[{"inV":2,"inVLabel":"vertex","outVLabel":"vertex","id":7,"label":"knows","type":"edge","outV":1,"hiddens":{},"properties":{"weight":0.5}}],"outE":[],"id":2,"label":"vertex","type":"vertex","hiddens":{"gremlin.pageRank":0.19250000000000003,"gremlin.edgeCount":0.0},"properties":{"name":"vadas","age":27}}
{"inE":[],"outE":[{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":12,"label":"created","type":"edge","outV":6,"hiddens":{},"properties":{"weight":0.2}}],"id":6,"label":"vertex","type":"vertex","hiddens":{"gremlin.pageRank":0.15000000000000002,"gremlin.edgeCount":1.0},"properties":{"name":"peter","age":35}}

Vertex 4 ("josh") is isolated below:

[source,js]
{
 "inE":[
  {"inV":4,"inVLabel":"vertex","outVLabel":"vertex","id":8,
    "label":"knows","type":"edge","outV":1,"hiddens":{},"properties":{"weight":1.0}}
 ],
 "outE":[
  {"inV":5,"inVLabel":"vertex","outVLabel":"vertex","id":10,
    "label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":1.0}},
  {"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":11,
    "label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":0.4}}
 ],
 "id":4,
 "label":"vertex",
 "type":"vertex",
 "hiddens":{
  "gremlin.pageRank":0.19250000000000003,
  "gremlin.edgeCount":2.0
 },
 "properties":{
  "name":"josh",
  "age":32
 }
}

Conclusion
==========

image:tinkerpop-character.png[width=100,float=left] The world that we know, you and me, is but a subset of the world that Gremlin has weaved within The TinkerPop. Gremlin has constructed a fully connected graph and only the subset that makes logical sense to our traversing thoughts is the fragment we have come to know and have come to see one another within. But there are many more out there, within other webs of logics unfathomed. From any thought, every other thought, we come to realize that which is -- The TinkerPop.

TinkerPop Contributors
======================

TinkerPop is a group of graph developers and vendors committed to providing a vendor-agnostic graph computing abstraction in support of technology interoperability.

Graph Developers
----------------

[width="100%",cols="5,10,2"]
|=========================================================
| link:http://markorodriguez.com[Marko A. Rodriguez] (2009) | TinkerPop co-founder and creator and developer of Gremlin.|
| link:http://se.linkedin.com/in/neubauer[Peter Neubauer] (2009) | TinkerPop co-founder and Neo Technology representative.| link:http://neo4j.org[*Neo4j*]
| link:http://fortytwo.net[Joshua Shinavier] (2009) | TinkerPop co-founder and full-stack developer.|
| link:http://ketrinayim.com[Ketrina Yim] (2009) | TinkerPop cartoonist and logo designer.|
| link:http://stephen.genoprime.com/[Stephen Mallette] (2011) | Primary developer on every aspect of TinkerPop.|
| link:http://www.linkedin.com/in/pierredewilde[Pierre De Wilde] (2011) | Documentation support and evangelist.| 
| link:http://github.com/pangloss[Derrick Wiebe] (2011) | Creator of Pacer and Gremlin traversal developer.|
| link:http://about.me/luca.garulli[Luca Garulli] (2012) | Orient Technologies representative and Gremlin structure theorist.| link:http://www.orientechnologies.com/orientdb/[*OrientDB*]
| link:http://www.matthiasb.com[Matthias Bröcheler] (2012) | Aurelius representative and full-stack theorist.| link:http://titan.thinkaurelius.com[*Titan*]
| link:http://jglue.org[Bryn Cooke] (2013) | Gremlin domain specific language theorist.|
| link:http://jamesthornton.com[James Thornton] (2013) | Creator of Bulbs and TinkerPop evangelist.|
| link:http://lambdazen.blogspot.com[Sridhar Ramachandran] (2013) | Lambda Zen representative and Gremlin traversal theorist.| link:https://bitbucket.org/lambdazen/bitsy/wiki/Home[*Bitsy*]
| link:http://www.linkedin.com/pub/nick-quinn/3/ab4/a56/[Nicholas Quinn] (2013) | Objectivity representative.| link:http://www.objectivity.com/infinitegraph[*InfiniteGraph*]
| link:http://www.linkedin.com/pub/xavier-sanchez/84/5b8/804[Xavier Sanchez] (2013) | Sparsity Technologies representative.| link:http://www.sparsity-technologies.com/#sparksee[*Sparksee*]
| link:http://twitter.com/dkuppitz[Daniel Kuppitz] (2014) | Gremlin traversal theorist and public technology support.|
| link:http://www.michaelpollmeier.com[Michael Pollmeier] (2014) | Gremlin-Scala creator and traversal theorist.|
| link:http://twitter.com/jbmusso[Jean-Baptiste Musso] (2014) | Gremlin-JavaScript creator.|
| link:http://bobbriody.com[Bob Briody] (2014) | Gremlin dashboard creator.|
| link:http://bigdata.com[Mike Personick] (2014) | Bigdata representative and OLAP theorist.| link:http://bigdata.com[*Bigdata*] 
| link:http://twitter.com/mchacki[Michael Hackstein] (2014) | ArangoDB representative.| link:http://arangodb.org[*ArangoDB*]
| link:http://github.com/MMcM[Michael McMahon] (2014) | FoundationDB representative.| link:http://foundationdb.com[*FoundationDB*]
| link:http://www.linkedin.com/pub/ryan-webb/39/23a/ab8[Ryan Webb] (2014) | Johns Hopkins Applied Physics Laboratory representative. | link:https://github.com/JHUAPL/AccumuloGraph[*AccumuloGraph*] 
| link:http://www.linkedin.com/in/averyching[Avery Ching] (2014) | Apache Giraph representative and OLAP theorist.| link:http://giraph.apache.org[*Giraph*]
|=========================================================


Graph Vendors
-------------

[width="100%"]
|=========================================================
| image:jhapl-logo.png[width=220,link="http://www.jhuapl.edu/"] | image:arangodb-logo.png[width=220,link="http://arangodb.com"] | image:aurelius-logo.png[width=220,link="http://thinkaurelius.com"] 
| image:bigdata-logo.png[width=220,link="http://bigdata.com"]| image:foundationdb-logo.png[width=220,link="https://foundationdb.com/"]| image:apache-giraph-logo.png[width=220,link="http://giraph.apache.org"]  
| image:lambda-zen-logo.png[width=220,link="http://lambdazen.blogspot.com"]| image:neotechnology-logo.png[width=220,link="http://neotechnology.com"]  | image:objectivity-logo.png[width=220,link="http://www.objectivity.com"]
| image:orientechnologies-logo.png[width=220,link="http://www.orientechnologies.com"] | image:sparsity-technologies-logo.png[width=220,link="http://www.sparsity-technologies.com/"]| 
|=========================================================


Acknowledgements
================

image:yourkit-logo.png[width=200,float=left] YourKit supports the TinkerPop open source project with its full-featured Java Profiler. YourKit, LLC is the creator of innovative and intelligent tools for profiling Java and .NET applications. YourKit's leading software products: link:http://www.yourkit.com/java/profiler/index.jsp[YourKit Java Profiler] and link:http://www.yourkit.com/.net/profiler/index.jsp[YourKit .NET Profiler]

...in the beginning. 
